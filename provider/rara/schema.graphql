# This file was generated. Do not edit manually.

schema {
    query: Query
    subscription: Subscription
}

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

type CuratorVaultToken {
    blockNumber: BigInt!
    createdAt: BigInt!
    curator: Bytes
    curatorTokenId: BigInt!
    curatorVaultAddress: Bytes!
    curator_comment: String
    curator_ipfsHash: String
    curator_tags: [String!]
    currentDepositBalance: BigDecimal!
    currentTokensOutstanding: BigInt!
    id: ID!
    nftChainId: BigInt!
    nftContractAddress: Bytes!
    nftId: BigInt!
    paymentToken: Bytes!
    takerCreatorRefunded: BigInt!
    takerRefunded: BigInt!
    takerTokensBalance: BigInt!
    totalDeposited: BigDecimal!
    totalTokenSold: BigInt!
    transactionHash: Bytes!
    updatedAt: BigInt!
    userSpends(first: Int = 100, orderBy: UserSpend_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: UserSpend_filter): [UserSpend!]!
}

type LikeTokenContract {
    blockNumber: BigInt!
    createdAt: BigInt!
    deployedContract: Bytes!
    id: ID!
    takerNftAddress: Bytes!
    takerNftChainId: BigInt!
    takerNftId: BigInt!
    updatedAt: BigInt!
}

type Query {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    curatorVaultToken(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): CuratorVaultToken
    curatorVaultTokens(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: CuratorVaultToken_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: CuratorVaultToken_filter
    ): [CuratorVaultToken!]!
    likeTokenContract(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): LikeTokenContract
    likeTokenContracts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: LikeTokenContract_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: LikeTokenContract_filter
    ): [LikeTokenContract!]!
    reaction(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Reaction
    reactions(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Reaction_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Reaction_filter
    ): [Reaction!]!
    source(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Source
    sources(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Source_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Source_filter
    ): [Source!]!
    transform(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Transform
    transforms(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Transform_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Transform_filter
    ): [Transform!]!
    userEarning(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserEarning
    userEarnings(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: UserEarning_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: UserEarning_filter
    ): [UserEarning!]!
    userPosition(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserPosition
    userPositions(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: UserPosition_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: UserPosition_filter
    ): [UserPosition!]!
    userReaction(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserReaction
    userReactions(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: UserReaction_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: UserReaction_filter
    ): [UserReaction!]!
    userSell(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserSell
    userSells(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: UserSell_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: UserSell_filter
    ): [UserSell!]!
    userSpend(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserSpend
    userSpends(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: UserSpend_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: UserSpend_filter
    ): [UserSpend!]!
}

type Reaction {
    blockNumber: BigInt!
    createdAt: BigInt!
    id: ID!
    parameterVersion: BigInt!
    reactionId: BigInt!
    totalCreatorFees: BigDecimal!
    totalMakerFees: BigDecimal!
    totalReferrerFees: BigDecimal!
    totalSold: BigInt!
    transform: Transform!
    updatedAt: BigInt!
}

type Source {
    blockNumber: BigInt!
    createdAt: BigInt!
    creatorAddresses: [String!]
    creatorSaleBasisPoints: [BigInt!]
    id: ID!
    nftChainId: BigInt!
    nftContractAddress: Bytes!
    nftId: BigInt!
    registered: Boolean!
    sourceId: BigInt!
    sourceIdHex: String
    updatedAt: BigInt!
    user: Bytes!
}

type Subscription {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    curatorVaultToken(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): CuratorVaultToken
    curatorVaultTokens(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: CuratorVaultToken_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: CuratorVaultToken_filter
    ): [CuratorVaultToken!]!
    likeTokenContract(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): LikeTokenContract
    likeTokenContracts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: LikeTokenContract_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: LikeTokenContract_filter
    ): [LikeTokenContract!]!
    reaction(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Reaction
    reactions(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Reaction_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Reaction_filter
    ): [Reaction!]!
    source(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Source
    sources(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Source_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Source_filter
    ): [Source!]!
    transform(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Transform
    transforms(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Transform_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Transform_filter
    ): [Transform!]!
    userEarning(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserEarning
    userEarnings(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: UserEarning_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: UserEarning_filter
    ): [UserEarning!]!
    userPosition(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserPosition
    userPositions(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: UserPosition_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: UserPosition_filter
    ): [UserPosition!]!
    userReaction(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserReaction
    userReactions(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: UserReaction_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: UserReaction_filter
    ): [UserReaction!]!
    userSell(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserSell
    userSells(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: UserSell_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: UserSell_filter
    ): [UserSell!]!
    userSpend(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): UserSpend
    userSpends(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: UserSpend_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: UserSpend_filter
    ): [UserSpend!]!
}

type Transform {
    blockNumber: BigInt!
    createdAt: BigInt!
    id: ID!
    ipfsHash: String
    name: String
    optionBits: BigInt!
    source: Source!
    tags: [String!]
    transformId: BigInt!
    updatedAt: BigInt!
}

type UserEarning {
    blockNumber: BigInt!
    createdAt: BigInt!
    currentCreatorRewards: BigDecimal!
    currentMakerRewards: BigDecimal!
    currentReferrerRewards: BigDecimal!
    id: ID!
    paymentToken: Bytes!
    totalCreatorRewards: BigDecimal!
    totalMakerRewards: BigDecimal!
    totalReferrerRewards: BigDecimal!
    totalRefunded: BigDecimal!
    updatedAt: BigInt!
    user: Bytes!
}

type UserPosition {
    blockNumber: BigInt!
    createdAt: BigInt!
    curatorVaultToken: CuratorVaultToken!
    currentTokenBalance: BigInt!
    id: ID!
    totalRefunded: BigDecimal!
    totalTokenPurchased: BigInt!
    updatedAt: BigInt!
    user: Bytes!
}

type UserReaction {
    blockNumber: BigInt!
    createdAt: BigInt!
    currentBalance: BigInt!
    id: ID!
    reaction: Reaction!
    totalPurchased: BigInt!
    updatedAt: BigInt!
    user: Bytes!
}

type UserSell {
    blockNumber: BigInt!
    createdAt: BigInt!
    curatorTokensSold: BigInt!
    curatorVaultToken: CuratorVaultToken!
    id: ID!
    paymentTokenRefunded: BigInt!
    updatedAt: BigInt!
    user: Bytes!
}

type UserSpend {
    blockNumber: BigInt!
    comment: String
    createdAt: BigInt!
    curatorTokensPurchased: BigInt
    curatorVaultToken: CuratorVaultToken
    id: ID!
    ipfsHash: String
    likeContractAddress: Bytes
    likeTokenId: BigInt
    reaction: Reaction
    reactionQuantity: BigInt
    tags: [String!]
    updatedAt: BigInt!
    user: Bytes!
}

type _Block_ {
    "The hash of the block"
    hash: Bytes
    "The block number"
    number: Int!
    "Integer representation of the timestamp stored in blocks for the chain"
    timestamp: Int
}

"The type for the top-level _meta field"
type _Meta_ {
    """

    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!
    "The deployment ID"
    deployment: String!
    "If `true`, the subgraph encountered indexing errors at some past block"
    hasIndexingErrors: Boolean!
}

enum CuratorVaultToken_orderBy {
    blockNumber
    createdAt
    curator
    curatorTokenId
    curatorVaultAddress
    curator_comment
    curator_ipfsHash
    curator_tags
    currentDepositBalance
    currentTokensOutstanding
    id
    nftChainId
    nftContractAddress
    nftId
    paymentToken
    takerCreatorRefunded
    takerRefunded
    takerTokensBalance
    totalDeposited
    totalTokenSold
    transactionHash
    updatedAt
    userSpends
}

enum LikeTokenContract_orderBy {
    blockNumber
    createdAt
    deployedContract
    id
    takerNftAddress
    takerNftChainId
    takerNftId
    updatedAt
}

"Defines the order direction, either ascending or descending"
enum OrderDirection {
    asc
    desc
}

enum Reaction_orderBy {
    blockNumber
    createdAt
    id
    parameterVersion
    reactionId
    totalCreatorFees
    totalMakerFees
    totalReferrerFees
    totalSold
    transform
    transform__blockNumber
    transform__createdAt
    transform__id
    transform__ipfsHash
    transform__name
    transform__optionBits
    transform__transformId
    transform__updatedAt
    updatedAt
}

enum Source_orderBy {
    blockNumber
    createdAt
    creatorAddresses
    creatorSaleBasisPoints
    id
    nftChainId
    nftContractAddress
    nftId
    registered
    sourceId
    sourceIdHex
    updatedAt
    user
}

enum Transform_orderBy {
    blockNumber
    createdAt
    id
    ipfsHash
    name
    optionBits
    source
    source__blockNumber
    source__createdAt
    source__id
    source__nftChainId
    source__nftContractAddress
    source__nftId
    source__registered
    source__sourceId
    source__sourceIdHex
    source__updatedAt
    source__user
    tags
    transformId
    updatedAt
}

enum UserEarning_orderBy {
    blockNumber
    createdAt
    currentCreatorRewards
    currentMakerRewards
    currentReferrerRewards
    id
    paymentToken
    totalCreatorRewards
    totalMakerRewards
    totalReferrerRewards
    totalRefunded
    updatedAt
    user
}

enum UserPosition_orderBy {
    blockNumber
    createdAt
    curatorVaultToken
    curatorVaultToken__blockNumber
    curatorVaultToken__createdAt
    curatorVaultToken__curator
    curatorVaultToken__curatorTokenId
    curatorVaultToken__curatorVaultAddress
    curatorVaultToken__curator_comment
    curatorVaultToken__curator_ipfsHash
    curatorVaultToken__currentDepositBalance
    curatorVaultToken__currentTokensOutstanding
    curatorVaultToken__id
    curatorVaultToken__nftChainId
    curatorVaultToken__nftContractAddress
    curatorVaultToken__nftId
    curatorVaultToken__paymentToken
    curatorVaultToken__takerCreatorRefunded
    curatorVaultToken__takerRefunded
    curatorVaultToken__takerTokensBalance
    curatorVaultToken__totalDeposited
    curatorVaultToken__totalTokenSold
    curatorVaultToken__transactionHash
    curatorVaultToken__updatedAt
    currentTokenBalance
    id
    totalRefunded
    totalTokenPurchased
    updatedAt
    user
}

enum UserReaction_orderBy {
    blockNumber
    createdAt
    currentBalance
    id
    reaction
    reaction__blockNumber
    reaction__createdAt
    reaction__id
    reaction__parameterVersion
    reaction__reactionId
    reaction__totalCreatorFees
    reaction__totalMakerFees
    reaction__totalReferrerFees
    reaction__totalSold
    reaction__updatedAt
    totalPurchased
    updatedAt
    user
}

enum UserSell_orderBy {
    blockNumber
    createdAt
    curatorTokensSold
    curatorVaultToken
    curatorVaultToken__blockNumber
    curatorVaultToken__createdAt
    curatorVaultToken__curator
    curatorVaultToken__curatorTokenId
    curatorVaultToken__curatorVaultAddress
    curatorVaultToken__curator_comment
    curatorVaultToken__curator_ipfsHash
    curatorVaultToken__currentDepositBalance
    curatorVaultToken__currentTokensOutstanding
    curatorVaultToken__id
    curatorVaultToken__nftChainId
    curatorVaultToken__nftContractAddress
    curatorVaultToken__nftId
    curatorVaultToken__paymentToken
    curatorVaultToken__takerCreatorRefunded
    curatorVaultToken__takerRefunded
    curatorVaultToken__takerTokensBalance
    curatorVaultToken__totalDeposited
    curatorVaultToken__totalTokenSold
    curatorVaultToken__transactionHash
    curatorVaultToken__updatedAt
    id
    paymentTokenRefunded
    updatedAt
    user
}

enum UserSpend_orderBy {
    blockNumber
    comment
    createdAt
    curatorTokensPurchased
    curatorVaultToken
    curatorVaultToken__blockNumber
    curatorVaultToken__createdAt
    curatorVaultToken__curator
    curatorVaultToken__curatorTokenId
    curatorVaultToken__curatorVaultAddress
    curatorVaultToken__curator_comment
    curatorVaultToken__curator_ipfsHash
    curatorVaultToken__currentDepositBalance
    curatorVaultToken__currentTokensOutstanding
    curatorVaultToken__id
    curatorVaultToken__nftChainId
    curatorVaultToken__nftContractAddress
    curatorVaultToken__nftId
    curatorVaultToken__paymentToken
    curatorVaultToken__takerCreatorRefunded
    curatorVaultToken__takerRefunded
    curatorVaultToken__takerTokensBalance
    curatorVaultToken__totalDeposited
    curatorVaultToken__totalTokenSold
    curatorVaultToken__transactionHash
    curatorVaultToken__updatedAt
    id
    ipfsHash
    likeContractAddress
    likeTokenId
    reaction
    reactionQuantity
    reaction__blockNumber
    reaction__createdAt
    reaction__id
    reaction__parameterVersion
    reaction__reactionId
    reaction__totalCreatorFees
    reaction__totalMakerFees
    reaction__totalReferrerFees
    reaction__totalSold
    reaction__updatedAt
    tags
    updatedAt
    user
}

enum _SubgraphErrorPolicy_ {
    "Data will be returned even if the subgraph has indexing errors"
    allow
    "If the subgraph has indexing errors, data will be omitted. The default."
    deny
}

scalar BigDecimal

scalar BigInt

scalar Bytes

"""

8 bytes signed integer
"""
scalar Int8

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

input CuratorVaultToken_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [CuratorVaultToken_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    createdAt: BigInt
    createdAt_gt: BigInt
    createdAt_gte: BigInt
    createdAt_in: [BigInt!]
    createdAt_lt: BigInt
    createdAt_lte: BigInt
    createdAt_not: BigInt
    createdAt_not_in: [BigInt!]
    curator: Bytes
    curatorTokenId: BigInt
    curatorTokenId_gt: BigInt
    curatorTokenId_gte: BigInt
    curatorTokenId_in: [BigInt!]
    curatorTokenId_lt: BigInt
    curatorTokenId_lte: BigInt
    curatorTokenId_not: BigInt
    curatorTokenId_not_in: [BigInt!]
    curatorVaultAddress: Bytes
    curatorVaultAddress_contains: Bytes
    curatorVaultAddress_gt: Bytes
    curatorVaultAddress_gte: Bytes
    curatorVaultAddress_in: [Bytes!]
    curatorVaultAddress_lt: Bytes
    curatorVaultAddress_lte: Bytes
    curatorVaultAddress_not: Bytes
    curatorVaultAddress_not_contains: Bytes
    curatorVaultAddress_not_in: [Bytes!]
    curator_comment: String
    curator_comment_contains: String
    curator_comment_contains_nocase: String
    curator_comment_ends_with: String
    curator_comment_ends_with_nocase: String
    curator_comment_gt: String
    curator_comment_gte: String
    curator_comment_in: [String!]
    curator_comment_lt: String
    curator_comment_lte: String
    curator_comment_not: String
    curator_comment_not_contains: String
    curator_comment_not_contains_nocase: String
    curator_comment_not_ends_with: String
    curator_comment_not_ends_with_nocase: String
    curator_comment_not_in: [String!]
    curator_comment_not_starts_with: String
    curator_comment_not_starts_with_nocase: String
    curator_comment_starts_with: String
    curator_comment_starts_with_nocase: String
    curator_contains: Bytes
    curator_gt: Bytes
    curator_gte: Bytes
    curator_in: [Bytes!]
    curator_ipfsHash: String
    curator_ipfsHash_contains: String
    curator_ipfsHash_contains_nocase: String
    curator_ipfsHash_ends_with: String
    curator_ipfsHash_ends_with_nocase: String
    curator_ipfsHash_gt: String
    curator_ipfsHash_gte: String
    curator_ipfsHash_in: [String!]
    curator_ipfsHash_lt: String
    curator_ipfsHash_lte: String
    curator_ipfsHash_not: String
    curator_ipfsHash_not_contains: String
    curator_ipfsHash_not_contains_nocase: String
    curator_ipfsHash_not_ends_with: String
    curator_ipfsHash_not_ends_with_nocase: String
    curator_ipfsHash_not_in: [String!]
    curator_ipfsHash_not_starts_with: String
    curator_ipfsHash_not_starts_with_nocase: String
    curator_ipfsHash_starts_with: String
    curator_ipfsHash_starts_with_nocase: String
    curator_lt: Bytes
    curator_lte: Bytes
    curator_not: Bytes
    curator_not_contains: Bytes
    curator_not_in: [Bytes!]
    curator_tags: [String!]
    curator_tags_contains: [String!]
    curator_tags_contains_nocase: [String!]
    curator_tags_not: [String!]
    curator_tags_not_contains: [String!]
    curator_tags_not_contains_nocase: [String!]
    currentDepositBalance: BigDecimal
    currentDepositBalance_gt: BigDecimal
    currentDepositBalance_gte: BigDecimal
    currentDepositBalance_in: [BigDecimal!]
    currentDepositBalance_lt: BigDecimal
    currentDepositBalance_lte: BigDecimal
    currentDepositBalance_not: BigDecimal
    currentDepositBalance_not_in: [BigDecimal!]
    currentTokensOutstanding: BigInt
    currentTokensOutstanding_gt: BigInt
    currentTokensOutstanding_gte: BigInt
    currentTokensOutstanding_in: [BigInt!]
    currentTokensOutstanding_lt: BigInt
    currentTokensOutstanding_lte: BigInt
    currentTokensOutstanding_not: BigInt
    currentTokensOutstanding_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    nftChainId: BigInt
    nftChainId_gt: BigInt
    nftChainId_gte: BigInt
    nftChainId_in: [BigInt!]
    nftChainId_lt: BigInt
    nftChainId_lte: BigInt
    nftChainId_not: BigInt
    nftChainId_not_in: [BigInt!]
    nftContractAddress: Bytes
    nftContractAddress_contains: Bytes
    nftContractAddress_gt: Bytes
    nftContractAddress_gte: Bytes
    nftContractAddress_in: [Bytes!]
    nftContractAddress_lt: Bytes
    nftContractAddress_lte: Bytes
    nftContractAddress_not: Bytes
    nftContractAddress_not_contains: Bytes
    nftContractAddress_not_in: [Bytes!]
    nftId: BigInt
    nftId_gt: BigInt
    nftId_gte: BigInt
    nftId_in: [BigInt!]
    nftId_lt: BigInt
    nftId_lte: BigInt
    nftId_not: BigInt
    nftId_not_in: [BigInt!]
    or: [CuratorVaultToken_filter]
    paymentToken: Bytes
    paymentToken_contains: Bytes
    paymentToken_gt: Bytes
    paymentToken_gte: Bytes
    paymentToken_in: [Bytes!]
    paymentToken_lt: Bytes
    paymentToken_lte: Bytes
    paymentToken_not: Bytes
    paymentToken_not_contains: Bytes
    paymentToken_not_in: [Bytes!]
    takerCreatorRefunded: BigInt
    takerCreatorRefunded_gt: BigInt
    takerCreatorRefunded_gte: BigInt
    takerCreatorRefunded_in: [BigInt!]
    takerCreatorRefunded_lt: BigInt
    takerCreatorRefunded_lte: BigInt
    takerCreatorRefunded_not: BigInt
    takerCreatorRefunded_not_in: [BigInt!]
    takerRefunded: BigInt
    takerRefunded_gt: BigInt
    takerRefunded_gte: BigInt
    takerRefunded_in: [BigInt!]
    takerRefunded_lt: BigInt
    takerRefunded_lte: BigInt
    takerRefunded_not: BigInt
    takerRefunded_not_in: [BigInt!]
    takerTokensBalance: BigInt
    takerTokensBalance_gt: BigInt
    takerTokensBalance_gte: BigInt
    takerTokensBalance_in: [BigInt!]
    takerTokensBalance_lt: BigInt
    takerTokensBalance_lte: BigInt
    takerTokensBalance_not: BigInt
    takerTokensBalance_not_in: [BigInt!]
    totalDeposited: BigDecimal
    totalDeposited_gt: BigDecimal
    totalDeposited_gte: BigDecimal
    totalDeposited_in: [BigDecimal!]
    totalDeposited_lt: BigDecimal
    totalDeposited_lte: BigDecimal
    totalDeposited_not: BigDecimal
    totalDeposited_not_in: [BigDecimal!]
    totalTokenSold: BigInt
    totalTokenSold_gt: BigInt
    totalTokenSold_gte: BigInt
    totalTokenSold_in: [BigInt!]
    totalTokenSold_lt: BigInt
    totalTokenSold_lte: BigInt
    totalTokenSold_not: BigInt
    totalTokenSold_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_gt: Bytes
    transactionHash_gte: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_lt: Bytes
    transactionHash_lte: Bytes
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    updatedAt: BigInt
    updatedAt_gt: BigInt
    updatedAt_gte: BigInt
    updatedAt_in: [BigInt!]
    updatedAt_lt: BigInt
    updatedAt_lte: BigInt
    updatedAt_not: BigInt
    updatedAt_not_in: [BigInt!]
    userSpends_: UserSpend_filter
}

input LikeTokenContract_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [LikeTokenContract_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    createdAt: BigInt
    createdAt_gt: BigInt
    createdAt_gte: BigInt
    createdAt_in: [BigInt!]
    createdAt_lt: BigInt
    createdAt_lte: BigInt
    createdAt_not: BigInt
    createdAt_not_in: [BigInt!]
    deployedContract: Bytes
    deployedContract_contains: Bytes
    deployedContract_gt: Bytes
    deployedContract_gte: Bytes
    deployedContract_in: [Bytes!]
    deployedContract_lt: Bytes
    deployedContract_lte: Bytes
    deployedContract_not: Bytes
    deployedContract_not_contains: Bytes
    deployedContract_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [LikeTokenContract_filter]
    takerNftAddress: Bytes
    takerNftAddress_contains: Bytes
    takerNftAddress_gt: Bytes
    takerNftAddress_gte: Bytes
    takerNftAddress_in: [Bytes!]
    takerNftAddress_lt: Bytes
    takerNftAddress_lte: Bytes
    takerNftAddress_not: Bytes
    takerNftAddress_not_contains: Bytes
    takerNftAddress_not_in: [Bytes!]
    takerNftChainId: BigInt
    takerNftChainId_gt: BigInt
    takerNftChainId_gte: BigInt
    takerNftChainId_in: [BigInt!]
    takerNftChainId_lt: BigInt
    takerNftChainId_lte: BigInt
    takerNftChainId_not: BigInt
    takerNftChainId_not_in: [BigInt!]
    takerNftId: BigInt
    takerNftId_gt: BigInt
    takerNftId_gte: BigInt
    takerNftId_in: [BigInt!]
    takerNftId_lt: BigInt
    takerNftId_lte: BigInt
    takerNftId_not: BigInt
    takerNftId_not_in: [BigInt!]
    updatedAt: BigInt
    updatedAt_gt: BigInt
    updatedAt_gte: BigInt
    updatedAt_in: [BigInt!]
    updatedAt_lt: BigInt
    updatedAt_lte: BigInt
    updatedAt_not: BigInt
    updatedAt_not_in: [BigInt!]
}

input Reaction_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [Reaction_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    createdAt: BigInt
    createdAt_gt: BigInt
    createdAt_gte: BigInt
    createdAt_in: [BigInt!]
    createdAt_lt: BigInt
    createdAt_lte: BigInt
    createdAt_not: BigInt
    createdAt_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [Reaction_filter]
    parameterVersion: BigInt
    parameterVersion_gt: BigInt
    parameterVersion_gte: BigInt
    parameterVersion_in: [BigInt!]
    parameterVersion_lt: BigInt
    parameterVersion_lte: BigInt
    parameterVersion_not: BigInt
    parameterVersion_not_in: [BigInt!]
    reactionId: BigInt
    reactionId_gt: BigInt
    reactionId_gte: BigInt
    reactionId_in: [BigInt!]
    reactionId_lt: BigInt
    reactionId_lte: BigInt
    reactionId_not: BigInt
    reactionId_not_in: [BigInt!]
    totalCreatorFees: BigDecimal
    totalCreatorFees_gt: BigDecimal
    totalCreatorFees_gte: BigDecimal
    totalCreatorFees_in: [BigDecimal!]
    totalCreatorFees_lt: BigDecimal
    totalCreatorFees_lte: BigDecimal
    totalCreatorFees_not: BigDecimal
    totalCreatorFees_not_in: [BigDecimal!]
    totalMakerFees: BigDecimal
    totalMakerFees_gt: BigDecimal
    totalMakerFees_gte: BigDecimal
    totalMakerFees_in: [BigDecimal!]
    totalMakerFees_lt: BigDecimal
    totalMakerFees_lte: BigDecimal
    totalMakerFees_not: BigDecimal
    totalMakerFees_not_in: [BigDecimal!]
    totalReferrerFees: BigDecimal
    totalReferrerFees_gt: BigDecimal
    totalReferrerFees_gte: BigDecimal
    totalReferrerFees_in: [BigDecimal!]
    totalReferrerFees_lt: BigDecimal
    totalReferrerFees_lte: BigDecimal
    totalReferrerFees_not: BigDecimal
    totalReferrerFees_not_in: [BigDecimal!]
    totalSold: BigInt
    totalSold_gt: BigInt
    totalSold_gte: BigInt
    totalSold_in: [BigInt!]
    totalSold_lt: BigInt
    totalSold_lte: BigInt
    totalSold_not: BigInt
    totalSold_not_in: [BigInt!]
    transform: String
    transform_: Transform_filter
    transform_contains: String
    transform_contains_nocase: String
    transform_ends_with: String
    transform_ends_with_nocase: String
    transform_gt: String
    transform_gte: String
    transform_in: [String!]
    transform_lt: String
    transform_lte: String
    transform_not: String
    transform_not_contains: String
    transform_not_contains_nocase: String
    transform_not_ends_with: String
    transform_not_ends_with_nocase: String
    transform_not_in: [String!]
    transform_not_starts_with: String
    transform_not_starts_with_nocase: String
    transform_starts_with: String
    transform_starts_with_nocase: String
    updatedAt: BigInt
    updatedAt_gt: BigInt
    updatedAt_gte: BigInt
    updatedAt_in: [BigInt!]
    updatedAt_lt: BigInt
    updatedAt_lte: BigInt
    updatedAt_not: BigInt
    updatedAt_not_in: [BigInt!]
}

input Source_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [Source_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    createdAt: BigInt
    createdAt_gt: BigInt
    createdAt_gte: BigInt
    createdAt_in: [BigInt!]
    createdAt_lt: BigInt
    createdAt_lte: BigInt
    createdAt_not: BigInt
    createdAt_not_in: [BigInt!]
    creatorAddresses: [String!]
    creatorAddresses_contains: [String!]
    creatorAddresses_contains_nocase: [String!]
    creatorAddresses_not: [String!]
    creatorAddresses_not_contains: [String!]
    creatorAddresses_not_contains_nocase: [String!]
    creatorSaleBasisPoints: [BigInt!]
    creatorSaleBasisPoints_contains: [BigInt!]
    creatorSaleBasisPoints_contains_nocase: [BigInt!]
    creatorSaleBasisPoints_not: [BigInt!]
    creatorSaleBasisPoints_not_contains: [BigInt!]
    creatorSaleBasisPoints_not_contains_nocase: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    nftChainId: BigInt
    nftChainId_gt: BigInt
    nftChainId_gte: BigInt
    nftChainId_in: [BigInt!]
    nftChainId_lt: BigInt
    nftChainId_lte: BigInt
    nftChainId_not: BigInt
    nftChainId_not_in: [BigInt!]
    nftContractAddress: Bytes
    nftContractAddress_contains: Bytes
    nftContractAddress_gt: Bytes
    nftContractAddress_gte: Bytes
    nftContractAddress_in: [Bytes!]
    nftContractAddress_lt: Bytes
    nftContractAddress_lte: Bytes
    nftContractAddress_not: Bytes
    nftContractAddress_not_contains: Bytes
    nftContractAddress_not_in: [Bytes!]
    nftId: BigInt
    nftId_gt: BigInt
    nftId_gte: BigInt
    nftId_in: [BigInt!]
    nftId_lt: BigInt
    nftId_lte: BigInt
    nftId_not: BigInt
    nftId_not_in: [BigInt!]
    or: [Source_filter]
    registered: Boolean
    registered_in: [Boolean!]
    registered_not: Boolean
    registered_not_in: [Boolean!]
    sourceId: BigInt
    sourceIdHex: String
    sourceIdHex_contains: String
    sourceIdHex_contains_nocase: String
    sourceIdHex_ends_with: String
    sourceIdHex_ends_with_nocase: String
    sourceIdHex_gt: String
    sourceIdHex_gte: String
    sourceIdHex_in: [String!]
    sourceIdHex_lt: String
    sourceIdHex_lte: String
    sourceIdHex_not: String
    sourceIdHex_not_contains: String
    sourceIdHex_not_contains_nocase: String
    sourceIdHex_not_ends_with: String
    sourceIdHex_not_ends_with_nocase: String
    sourceIdHex_not_in: [String!]
    sourceIdHex_not_starts_with: String
    sourceIdHex_not_starts_with_nocase: String
    sourceIdHex_starts_with: String
    sourceIdHex_starts_with_nocase: String
    sourceId_gt: BigInt
    sourceId_gte: BigInt
    sourceId_in: [BigInt!]
    sourceId_lt: BigInt
    sourceId_lte: BigInt
    sourceId_not: BigInt
    sourceId_not_in: [BigInt!]
    updatedAt: BigInt
    updatedAt_gt: BigInt
    updatedAt_gte: BigInt
    updatedAt_in: [BigInt!]
    updatedAt_lt: BigInt
    updatedAt_lte: BigInt
    updatedAt_not: BigInt
    updatedAt_not_in: [BigInt!]
    user: Bytes
    user_contains: Bytes
    user_gt: Bytes
    user_gte: Bytes
    user_in: [Bytes!]
    user_lt: Bytes
    user_lte: Bytes
    user_not: Bytes
    user_not_contains: Bytes
    user_not_in: [Bytes!]
}

input Transform_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [Transform_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    createdAt: BigInt
    createdAt_gt: BigInt
    createdAt_gte: BigInt
    createdAt_in: [BigInt!]
    createdAt_lt: BigInt
    createdAt_lte: BigInt
    createdAt_not: BigInt
    createdAt_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    ipfsHash: String
    ipfsHash_contains: String
    ipfsHash_contains_nocase: String
    ipfsHash_ends_with: String
    ipfsHash_ends_with_nocase: String
    ipfsHash_gt: String
    ipfsHash_gte: String
    ipfsHash_in: [String!]
    ipfsHash_lt: String
    ipfsHash_lte: String
    ipfsHash_not: String
    ipfsHash_not_contains: String
    ipfsHash_not_contains_nocase: String
    ipfsHash_not_ends_with: String
    ipfsHash_not_ends_with_nocase: String
    ipfsHash_not_in: [String!]
    ipfsHash_not_starts_with: String
    ipfsHash_not_starts_with_nocase: String
    ipfsHash_starts_with: String
    ipfsHash_starts_with_nocase: String
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    optionBits: BigInt
    optionBits_gt: BigInt
    optionBits_gte: BigInt
    optionBits_in: [BigInt!]
    optionBits_lt: BigInt
    optionBits_lte: BigInt
    optionBits_not: BigInt
    optionBits_not_in: [BigInt!]
    or: [Transform_filter]
    source: String
    source_: Source_filter
    source_contains: String
    source_contains_nocase: String
    source_ends_with: String
    source_ends_with_nocase: String
    source_gt: String
    source_gte: String
    source_in: [String!]
    source_lt: String
    source_lte: String
    source_not: String
    source_not_contains: String
    source_not_contains_nocase: String
    source_not_ends_with: String
    source_not_ends_with_nocase: String
    source_not_in: [String!]
    source_not_starts_with: String
    source_not_starts_with_nocase: String
    source_starts_with: String
    source_starts_with_nocase: String
    tags: [String!]
    tags_contains: [String!]
    tags_contains_nocase: [String!]
    tags_not: [String!]
    tags_not_contains: [String!]
    tags_not_contains_nocase: [String!]
    transformId: BigInt
    transformId_gt: BigInt
    transformId_gte: BigInt
    transformId_in: [BigInt!]
    transformId_lt: BigInt
    transformId_lte: BigInt
    transformId_not: BigInt
    transformId_not_in: [BigInt!]
    updatedAt: BigInt
    updatedAt_gt: BigInt
    updatedAt_gte: BigInt
    updatedAt_in: [BigInt!]
    updatedAt_lt: BigInt
    updatedAt_lte: BigInt
    updatedAt_not: BigInt
    updatedAt_not_in: [BigInt!]
}

input UserEarning_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [UserEarning_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    createdAt: BigInt
    createdAt_gt: BigInt
    createdAt_gte: BigInt
    createdAt_in: [BigInt!]
    createdAt_lt: BigInt
    createdAt_lte: BigInt
    createdAt_not: BigInt
    createdAt_not_in: [BigInt!]
    currentCreatorRewards: BigDecimal
    currentCreatorRewards_gt: BigDecimal
    currentCreatorRewards_gte: BigDecimal
    currentCreatorRewards_in: [BigDecimal!]
    currentCreatorRewards_lt: BigDecimal
    currentCreatorRewards_lte: BigDecimal
    currentCreatorRewards_not: BigDecimal
    currentCreatorRewards_not_in: [BigDecimal!]
    currentMakerRewards: BigDecimal
    currentMakerRewards_gt: BigDecimal
    currentMakerRewards_gte: BigDecimal
    currentMakerRewards_in: [BigDecimal!]
    currentMakerRewards_lt: BigDecimal
    currentMakerRewards_lte: BigDecimal
    currentMakerRewards_not: BigDecimal
    currentMakerRewards_not_in: [BigDecimal!]
    currentReferrerRewards: BigDecimal
    currentReferrerRewards_gt: BigDecimal
    currentReferrerRewards_gte: BigDecimal
    currentReferrerRewards_in: [BigDecimal!]
    currentReferrerRewards_lt: BigDecimal
    currentReferrerRewards_lte: BigDecimal
    currentReferrerRewards_not: BigDecimal
    currentReferrerRewards_not_in: [BigDecimal!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [UserEarning_filter]
    paymentToken: Bytes
    paymentToken_contains: Bytes
    paymentToken_gt: Bytes
    paymentToken_gte: Bytes
    paymentToken_in: [Bytes!]
    paymentToken_lt: Bytes
    paymentToken_lte: Bytes
    paymentToken_not: Bytes
    paymentToken_not_contains: Bytes
    paymentToken_not_in: [Bytes!]
    totalCreatorRewards: BigDecimal
    totalCreatorRewards_gt: BigDecimal
    totalCreatorRewards_gte: BigDecimal
    totalCreatorRewards_in: [BigDecimal!]
    totalCreatorRewards_lt: BigDecimal
    totalCreatorRewards_lte: BigDecimal
    totalCreatorRewards_not: BigDecimal
    totalCreatorRewards_not_in: [BigDecimal!]
    totalMakerRewards: BigDecimal
    totalMakerRewards_gt: BigDecimal
    totalMakerRewards_gte: BigDecimal
    totalMakerRewards_in: [BigDecimal!]
    totalMakerRewards_lt: BigDecimal
    totalMakerRewards_lte: BigDecimal
    totalMakerRewards_not: BigDecimal
    totalMakerRewards_not_in: [BigDecimal!]
    totalReferrerRewards: BigDecimal
    totalReferrerRewards_gt: BigDecimal
    totalReferrerRewards_gte: BigDecimal
    totalReferrerRewards_in: [BigDecimal!]
    totalReferrerRewards_lt: BigDecimal
    totalReferrerRewards_lte: BigDecimal
    totalReferrerRewards_not: BigDecimal
    totalReferrerRewards_not_in: [BigDecimal!]
    totalRefunded: BigDecimal
    totalRefunded_gt: BigDecimal
    totalRefunded_gte: BigDecimal
    totalRefunded_in: [BigDecimal!]
    totalRefunded_lt: BigDecimal
    totalRefunded_lte: BigDecimal
    totalRefunded_not: BigDecimal
    totalRefunded_not_in: [BigDecimal!]
    updatedAt: BigInt
    updatedAt_gt: BigInt
    updatedAt_gte: BigInt
    updatedAt_in: [BigInt!]
    updatedAt_lt: BigInt
    updatedAt_lte: BigInt
    updatedAt_not: BigInt
    updatedAt_not_in: [BigInt!]
    user: Bytes
    user_contains: Bytes
    user_gt: Bytes
    user_gte: Bytes
    user_in: [Bytes!]
    user_lt: Bytes
    user_lte: Bytes
    user_not: Bytes
    user_not_contains: Bytes
    user_not_in: [Bytes!]
}

input UserPosition_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [UserPosition_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    createdAt: BigInt
    createdAt_gt: BigInt
    createdAt_gte: BigInt
    createdAt_in: [BigInt!]
    createdAt_lt: BigInt
    createdAt_lte: BigInt
    createdAt_not: BigInt
    createdAt_not_in: [BigInt!]
    curatorVaultToken: String
    curatorVaultToken_: CuratorVaultToken_filter
    curatorVaultToken_contains: String
    curatorVaultToken_contains_nocase: String
    curatorVaultToken_ends_with: String
    curatorVaultToken_ends_with_nocase: String
    curatorVaultToken_gt: String
    curatorVaultToken_gte: String
    curatorVaultToken_in: [String!]
    curatorVaultToken_lt: String
    curatorVaultToken_lte: String
    curatorVaultToken_not: String
    curatorVaultToken_not_contains: String
    curatorVaultToken_not_contains_nocase: String
    curatorVaultToken_not_ends_with: String
    curatorVaultToken_not_ends_with_nocase: String
    curatorVaultToken_not_in: [String!]
    curatorVaultToken_not_starts_with: String
    curatorVaultToken_not_starts_with_nocase: String
    curatorVaultToken_starts_with: String
    curatorVaultToken_starts_with_nocase: String
    currentTokenBalance: BigInt
    currentTokenBalance_gt: BigInt
    currentTokenBalance_gte: BigInt
    currentTokenBalance_in: [BigInt!]
    currentTokenBalance_lt: BigInt
    currentTokenBalance_lte: BigInt
    currentTokenBalance_not: BigInt
    currentTokenBalance_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [UserPosition_filter]
    totalRefunded: BigDecimal
    totalRefunded_gt: BigDecimal
    totalRefunded_gte: BigDecimal
    totalRefunded_in: [BigDecimal!]
    totalRefunded_lt: BigDecimal
    totalRefunded_lte: BigDecimal
    totalRefunded_not: BigDecimal
    totalRefunded_not_in: [BigDecimal!]
    totalTokenPurchased: BigInt
    totalTokenPurchased_gt: BigInt
    totalTokenPurchased_gte: BigInt
    totalTokenPurchased_in: [BigInt!]
    totalTokenPurchased_lt: BigInt
    totalTokenPurchased_lte: BigInt
    totalTokenPurchased_not: BigInt
    totalTokenPurchased_not_in: [BigInt!]
    updatedAt: BigInt
    updatedAt_gt: BigInt
    updatedAt_gte: BigInt
    updatedAt_in: [BigInt!]
    updatedAt_lt: BigInt
    updatedAt_lte: BigInt
    updatedAt_not: BigInt
    updatedAt_not_in: [BigInt!]
    user: Bytes
    user_contains: Bytes
    user_gt: Bytes
    user_gte: Bytes
    user_in: [Bytes!]
    user_lt: Bytes
    user_lte: Bytes
    user_not: Bytes
    user_not_contains: Bytes
    user_not_in: [Bytes!]
}

input UserReaction_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [UserReaction_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    createdAt: BigInt
    createdAt_gt: BigInt
    createdAt_gte: BigInt
    createdAt_in: [BigInt!]
    createdAt_lt: BigInt
    createdAt_lte: BigInt
    createdAt_not: BigInt
    createdAt_not_in: [BigInt!]
    currentBalance: BigInt
    currentBalance_gt: BigInt
    currentBalance_gte: BigInt
    currentBalance_in: [BigInt!]
    currentBalance_lt: BigInt
    currentBalance_lte: BigInt
    currentBalance_not: BigInt
    currentBalance_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [UserReaction_filter]
    reaction: String
    reaction_: Reaction_filter
    reaction_contains: String
    reaction_contains_nocase: String
    reaction_ends_with: String
    reaction_ends_with_nocase: String
    reaction_gt: String
    reaction_gte: String
    reaction_in: [String!]
    reaction_lt: String
    reaction_lte: String
    reaction_not: String
    reaction_not_contains: String
    reaction_not_contains_nocase: String
    reaction_not_ends_with: String
    reaction_not_ends_with_nocase: String
    reaction_not_in: [String!]
    reaction_not_starts_with: String
    reaction_not_starts_with_nocase: String
    reaction_starts_with: String
    reaction_starts_with_nocase: String
    totalPurchased: BigInt
    totalPurchased_gt: BigInt
    totalPurchased_gte: BigInt
    totalPurchased_in: [BigInt!]
    totalPurchased_lt: BigInt
    totalPurchased_lte: BigInt
    totalPurchased_not: BigInt
    totalPurchased_not_in: [BigInt!]
    updatedAt: BigInt
    updatedAt_gt: BigInt
    updatedAt_gte: BigInt
    updatedAt_in: [BigInt!]
    updatedAt_lt: BigInt
    updatedAt_lte: BigInt
    updatedAt_not: BigInt
    updatedAt_not_in: [BigInt!]
    user: Bytes
    user_contains: Bytes
    user_gt: Bytes
    user_gte: Bytes
    user_in: [Bytes!]
    user_lt: Bytes
    user_lte: Bytes
    user_not: Bytes
    user_not_contains: Bytes
    user_not_in: [Bytes!]
}

input UserSell_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [UserSell_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    createdAt: BigInt
    createdAt_gt: BigInt
    createdAt_gte: BigInt
    createdAt_in: [BigInt!]
    createdAt_lt: BigInt
    createdAt_lte: BigInt
    createdAt_not: BigInt
    createdAt_not_in: [BigInt!]
    curatorTokensSold: BigInt
    curatorTokensSold_gt: BigInt
    curatorTokensSold_gte: BigInt
    curatorTokensSold_in: [BigInt!]
    curatorTokensSold_lt: BigInt
    curatorTokensSold_lte: BigInt
    curatorTokensSold_not: BigInt
    curatorTokensSold_not_in: [BigInt!]
    curatorVaultToken: String
    curatorVaultToken_: CuratorVaultToken_filter
    curatorVaultToken_contains: String
    curatorVaultToken_contains_nocase: String
    curatorVaultToken_ends_with: String
    curatorVaultToken_ends_with_nocase: String
    curatorVaultToken_gt: String
    curatorVaultToken_gte: String
    curatorVaultToken_in: [String!]
    curatorVaultToken_lt: String
    curatorVaultToken_lte: String
    curatorVaultToken_not: String
    curatorVaultToken_not_contains: String
    curatorVaultToken_not_contains_nocase: String
    curatorVaultToken_not_ends_with: String
    curatorVaultToken_not_ends_with_nocase: String
    curatorVaultToken_not_in: [String!]
    curatorVaultToken_not_starts_with: String
    curatorVaultToken_not_starts_with_nocase: String
    curatorVaultToken_starts_with: String
    curatorVaultToken_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [UserSell_filter]
    paymentTokenRefunded: BigInt
    paymentTokenRefunded_gt: BigInt
    paymentTokenRefunded_gte: BigInt
    paymentTokenRefunded_in: [BigInt!]
    paymentTokenRefunded_lt: BigInt
    paymentTokenRefunded_lte: BigInt
    paymentTokenRefunded_not: BigInt
    paymentTokenRefunded_not_in: [BigInt!]
    updatedAt: BigInt
    updatedAt_gt: BigInt
    updatedAt_gte: BigInt
    updatedAt_in: [BigInt!]
    updatedAt_lt: BigInt
    updatedAt_lte: BigInt
    updatedAt_not: BigInt
    updatedAt_not_in: [BigInt!]
    user: Bytes
    user_contains: Bytes
    user_gt: Bytes
    user_gte: Bytes
    user_in: [Bytes!]
    user_lt: Bytes
    user_lte: Bytes
    user_not: Bytes
    user_not_contains: Bytes
    user_not_in: [Bytes!]
}

input UserSpend_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [UserSpend_filter]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    comment: String
    comment_contains: String
    comment_contains_nocase: String
    comment_ends_with: String
    comment_ends_with_nocase: String
    comment_gt: String
    comment_gte: String
    comment_in: [String!]
    comment_lt: String
    comment_lte: String
    comment_not: String
    comment_not_contains: String
    comment_not_contains_nocase: String
    comment_not_ends_with: String
    comment_not_ends_with_nocase: String
    comment_not_in: [String!]
    comment_not_starts_with: String
    comment_not_starts_with_nocase: String
    comment_starts_with: String
    comment_starts_with_nocase: String
    createdAt: BigInt
    createdAt_gt: BigInt
    createdAt_gte: BigInt
    createdAt_in: [BigInt!]
    createdAt_lt: BigInt
    createdAt_lte: BigInt
    createdAt_not: BigInt
    createdAt_not_in: [BigInt!]
    curatorTokensPurchased: BigInt
    curatorTokensPurchased_gt: BigInt
    curatorTokensPurchased_gte: BigInt
    curatorTokensPurchased_in: [BigInt!]
    curatorTokensPurchased_lt: BigInt
    curatorTokensPurchased_lte: BigInt
    curatorTokensPurchased_not: BigInt
    curatorTokensPurchased_not_in: [BigInt!]
    curatorVaultToken: String
    curatorVaultToken_: CuratorVaultToken_filter
    curatorVaultToken_contains: String
    curatorVaultToken_contains_nocase: String
    curatorVaultToken_ends_with: String
    curatorVaultToken_ends_with_nocase: String
    curatorVaultToken_gt: String
    curatorVaultToken_gte: String
    curatorVaultToken_in: [String!]
    curatorVaultToken_lt: String
    curatorVaultToken_lte: String
    curatorVaultToken_not: String
    curatorVaultToken_not_contains: String
    curatorVaultToken_not_contains_nocase: String
    curatorVaultToken_not_ends_with: String
    curatorVaultToken_not_ends_with_nocase: String
    curatorVaultToken_not_in: [String!]
    curatorVaultToken_not_starts_with: String
    curatorVaultToken_not_starts_with_nocase: String
    curatorVaultToken_starts_with: String
    curatorVaultToken_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    ipfsHash: String
    ipfsHash_contains: String
    ipfsHash_contains_nocase: String
    ipfsHash_ends_with: String
    ipfsHash_ends_with_nocase: String
    ipfsHash_gt: String
    ipfsHash_gte: String
    ipfsHash_in: [String!]
    ipfsHash_lt: String
    ipfsHash_lte: String
    ipfsHash_not: String
    ipfsHash_not_contains: String
    ipfsHash_not_contains_nocase: String
    ipfsHash_not_ends_with: String
    ipfsHash_not_ends_with_nocase: String
    ipfsHash_not_in: [String!]
    ipfsHash_not_starts_with: String
    ipfsHash_not_starts_with_nocase: String
    ipfsHash_starts_with: String
    ipfsHash_starts_with_nocase: String
    likeContractAddress: Bytes
    likeContractAddress_contains: Bytes
    likeContractAddress_gt: Bytes
    likeContractAddress_gte: Bytes
    likeContractAddress_in: [Bytes!]
    likeContractAddress_lt: Bytes
    likeContractAddress_lte: Bytes
    likeContractAddress_not: Bytes
    likeContractAddress_not_contains: Bytes
    likeContractAddress_not_in: [Bytes!]
    likeTokenId: BigInt
    likeTokenId_gt: BigInt
    likeTokenId_gte: BigInt
    likeTokenId_in: [BigInt!]
    likeTokenId_lt: BigInt
    likeTokenId_lte: BigInt
    likeTokenId_not: BigInt
    likeTokenId_not_in: [BigInt!]
    or: [UserSpend_filter]
    reaction: String
    reactionQuantity: BigInt
    reactionQuantity_gt: BigInt
    reactionQuantity_gte: BigInt
    reactionQuantity_in: [BigInt!]
    reactionQuantity_lt: BigInt
    reactionQuantity_lte: BigInt
    reactionQuantity_not: BigInt
    reactionQuantity_not_in: [BigInt!]
    reaction_: Reaction_filter
    reaction_contains: String
    reaction_contains_nocase: String
    reaction_ends_with: String
    reaction_ends_with_nocase: String
    reaction_gt: String
    reaction_gte: String
    reaction_in: [String!]
    reaction_lt: String
    reaction_lte: String
    reaction_not: String
    reaction_not_contains: String
    reaction_not_contains_nocase: String
    reaction_not_ends_with: String
    reaction_not_ends_with_nocase: String
    reaction_not_in: [String!]
    reaction_not_starts_with: String
    reaction_not_starts_with_nocase: String
    reaction_starts_with: String
    reaction_starts_with_nocase: String
    tags: [String!]
    tags_contains: [String!]
    tags_contains_nocase: [String!]
    tags_not: [String!]
    tags_not_contains: [String!]
    tags_not_contains_nocase: [String!]
    updatedAt: BigInt
    updatedAt_gt: BigInt
    updatedAt_gte: BigInt
    updatedAt_in: [BigInt!]
    updatedAt_lt: BigInt
    updatedAt_lte: BigInt
    updatedAt_not: BigInt
    updatedAt_not_in: [BigInt!]
    user: Bytes
    user_contains: Bytes
    user_gt: Bytes
    user_gte: Bytes
    user_in: [Bytes!]
    user_lt: Bytes
    user_lte: Bytes
    user_not: Bytes
    user_not_contains: Bytes
    user_not_in: [Bytes!]
}
