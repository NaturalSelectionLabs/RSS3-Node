// Package docs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package docs

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	"github.com/rss3-network/node/schema/worker/decentralized"
	"github.com/rss3-network/node/schema/worker/federated"
	"github.com/rss3-network/protocol-go/schema"
	activityx "github.com/rss3-network/protocol-go/schema/activity"
	"github.com/rss3-network/protocol-go/schema/network"
	tag "github.com/rss3-network/protocol-go/schema/tag"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// PostDecentralizedAccountsJSONBody defines parameters for PostDecentralizedAccounts.
type PostDecentralizedAccountsJSONBody struct {
	// Accounts List of accounts to retrieve activities for
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit int `json:"limit,omitempty"`

	// Network Retrieve activities from the specified network(s)
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag []tag.Tag `json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s)
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetDecentralizedNetworkNetworkParams defines parameters for GetDecentralizedNetworkNetwork.
type GetDecentralizedNetworkNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetDecentralizedPlatformPlatformParams defines parameters for GetDecentralizedPlatformPlatform.
type GetDecentralizedPlatformPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetDecentralizedTxIDParams defines parameters for GetDecentralizedTxID.
type GetDecentralizedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetDecentralizedAccountParams defines parameters for GetDecentralizedAccount.
type GetDecentralizedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostFederatedAccountsJSONBody defines parameters for PostFederatedAccounts.
type PostFederatedAccountsJSONBody struct {
	// Accounts List of accounts to retrieve activities for
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit int `json:"limit,omitempty"`

	// Network Retrieve activities from the specified network(s)
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []federated.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag []tag.Tag `json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s)
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetFederatedNetworkNetworkParams defines parameters for GetFederatedNetworkNetwork.
type GetFederatedNetworkNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetFederatedPlatformPlatformParams defines parameters for GetFederatedPlatformPlatform.
type GetFederatedPlatformPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetFederatedTxIDParams defines parameters for GetFederatedTxID.
type GetFederatedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetFederatedAccountParams defines parameters for GetFederatedAccount.
type GetFederatedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostDecentralizedAccountsJSONRequestBody defines body for PostDecentralizedAccounts for application/json ContentType.
type PostDecentralizedAccountsJSONRequestBody PostDecentralizedAccountsJSONBody

// PostFederatedAccountsJSONRequestBody defines body for PostFederatedAccounts for application/json ContentType.
type PostFederatedAccountsJSONRequestBody PostFederatedAccountsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Node Operator Info
	// (GET /)
	Get(ctx echo.Context) error
	// Get Node Activity Count
	// (GET /activity_count)
	GetActivityCount(ctx echo.Context) error
	// Batch Get Accounts Activities
	// (POST /decentralized/accounts)
	PostDecentralizedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /decentralized/network/{network})
	GetDecentralizedNetworkNetwork(ctx echo.Context, network network.Network, params GetDecentralizedNetworkNetworkParams) error
	// Get Platform Activities
	// (GET /decentralized/platform/{platform})
	GetDecentralizedPlatformPlatform(ctx echo.Context, platform decentralized.Platform, params GetDecentralizedPlatformPlatformParams) error
	// Get Activity by ID
	// (GET /decentralized/tx/{id})
	GetDecentralizedTxID(ctx echo.Context, id string, params GetDecentralizedTxIDParams) error
	// Get Account Activities
	// (GET /decentralized/{account})
	GetDecentralizedAccount(ctx echo.Context, account string, params GetDecentralizedAccountParams) error
	// Batch Get Accounts Activities
	// (POST /federated/accounts)
	PostFederatedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /federated/network/{network})
	GetFederatedNetworkNetwork(ctx echo.Context, network network.Network, params GetFederatedNetworkNetworkParams) error
	// Get Platform Activities
	// (GET /federated/platform/{platform})
	GetFederatedPlatformPlatform(ctx echo.Context, platform federated.Platform, params GetFederatedPlatformPlatformParams) error
	// Get Activity by ID
	// (GET /federated/tx/{id})
	GetFederatedTxID(ctx echo.Context, id string, params GetFederatedTxIDParams) error
	// Get Account Activities
	// (GET /federated/{account})
	GetFederatedAccount(ctx echo.Context, account string, params GetFederatedAccountParams) error
	// Get worker config options
	// (GET /networks/config)
	GetNetworksConfig(ctx echo.Context) error
	// Get Node Status
	// (GET /operators/info)
	GetOperatorsInfo(ctx echo.Context) error
	// Get Node Worker Status
	// (GET /operators/workers_status)
	GetOperatorsWorkersStatus(ctx echo.Context) error
	// Get RSS Activity by Path
	// (GET /rss/{path})
	GetRSS(ctx echo.Context, path string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Get converts echo context to params.
func (w *ServerInterfaceWrapper) Get(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Get(ctx)
	return err
}

// GetActivityCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetActivityCount(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetActivityCount(ctx)
	return err
}

// PostDecentralizedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedAccounts(ctx)
	return err
}

// GetDecentralizedNetworkNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedNetworkNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedNetworkNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedNetworkNetwork(ctx, network, params)
	return err
}

// GetDecentralizedPlatformPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedPlatformPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform decentralized.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedPlatformPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedPlatformPlatform(ctx, platform, params)
	return err
}

// GetDecentralizedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedTxID(ctx, id, params)
	return err
}

// GetDecentralizedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedAccount(ctx, account, params)
	return err
}

// PostFederatedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostFederatedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFederatedAccounts(ctx)
	return err
}

// GetFederatedNetworkNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedNetworkNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedNetworkNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedNetworkNetwork(ctx, network, params)
	return err
}

// GetFederatedPlatformPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedPlatformPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform federated.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedPlatformPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedPlatformPlatform(ctx, platform, params)
	return err
}

// GetFederatedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedTxID(ctx, id, params)
	return err
}

// GetFederatedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedAccount(ctx, account, params)
	return err
}

// GetNetworksConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworksConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworksConfig(ctx)
	return err
}

// GetOperatorsInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetOperatorsInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOperatorsInfo(ctx)
	return err
}

// GetOperatorsWorkersStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetOperatorsWorkersStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOperatorsWorkersStatus(ctx)
	return err
}

// GetRSS converts echo context to params.
func (w *ServerInterfaceWrapper) GetRSS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRSS(ctx, path)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/", wrapper.Get)
	router.GET(baseURL+"/activity_count", wrapper.GetActivityCount)
	router.POST(baseURL+"/decentralized/accounts", wrapper.PostDecentralizedAccounts)
	router.GET(baseURL+"/decentralized/network/:network", wrapper.GetDecentralizedNetworkNetwork)
	router.GET(baseURL+"/decentralized/platform/:platform", wrapper.GetDecentralizedPlatformPlatform)
	router.GET(baseURL+"/decentralized/tx/:id", wrapper.GetDecentralizedTxID)
	router.GET(baseURL+"/decentralized/:account", wrapper.GetDecentralizedAccount)
	router.POST(baseURL+"/federated/accounts", wrapper.PostFederatedAccounts)
	router.GET(baseURL+"/federated/network/:network", wrapper.GetFederatedNetworkNetwork)
	router.GET(baseURL+"/federated/platform/:platform", wrapper.GetFederatedPlatformPlatform)
	router.GET(baseURL+"/federated/tx/:id", wrapper.GetFederatedTxID)
	router.GET(baseURL+"/federated/:account", wrapper.GetFederatedAccount)
	router.GET(baseURL+"/networks/config", wrapper.GetNetworksConfig)
	router.GET(baseURL+"/operators/info", wrapper.GetOperatorsInfo)
	router.GET(baseURL+"/operators/workers_status", wrapper.GetOperatorsWorkersStatus)
	router.GET(baseURL+"/rss/:path", wrapper.GetRSS)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9bXPbOJPgX2Hxtmp3q2SbpN795cpJnNnUJRmf5Zmp3SSngkhIwmOK4ACgZT0p//cr",
	"vJEgCcp6oTzJM86HWBKJRnej0Wh0Nxrf3RCvUpzAhFH38rubAgJWkEFS+TZNAVtOQRjiLGH8UQRpSFDK",
	"EE7cS/cWMoLgA3RAyNADYghSZ07wymFL6NAUhmiOYOSo9udux0W8GQfqdtwErKB76WroHZfAPzNEYORe",
	"MpLBjkvDJVwB3i18BKs05m97j9EoAoPZPBiMBz0wH0dDCKMx9Lqw3+35/ag7BGA88Hp9t+OyTcrbUEZQ",
	"snCfnjoW0gTimymKtpAXQQZQTJ05JjXSZHvnwzu3U0Jz1PNgL4j6wy6cQX8+D4ZgDHtjv9cfdmc96PX9",
	"0TyMBqN+OJyPu10/6vpjMIOjfm8+HHmwa2cWirby6XmCE8jWmNwfPJaq/XmJWsiWkMBsZcdZd7kN8X8j",
	"cO5euv/ropDLC/k0/zv9rODYyEpjwOaYrKYRDGHCCIjRP2F0MJUaXJnM3xJE1yC1U6mbHE1mTsq7Eilb",
	"qZ7DCBLAfnaK3+dk2KgllB40R28nE0dhXlAGZmEDVfLbgXPszwySjdAqOJnGaIUsWnMiMNsILJNsNYPE",
	"wXNHtqHOGrElSsTDXLkw7BBFZ3l8fE8TITo2laqBwb7jcSUafxRtt9GXggXcTl4KFigB/IEYF0WjSYK/",
	"FX/Rw2Ho3/CmVuzDjFBMtiMu33EyCiOBeUHIeQPHFdR9kX0rm1kRjRCBoURul1k9AxxbnDh5uyZcC8D7",
	"ovsub2nFeG+JV6g3CnjQJOCHSfYWmW5pYfwP+p9NXC/WwQJpxOCK7r0A5pYNIATwHh7PFviM/3ZG71F6",
	"hgXuID5LMUoYJFKJWck+0cK5hQ3GsnEgH5pWyFOwpb2V9WVYYiyhLbKDoiSEU4ZWkDKwSnfjBWWAMJQs",
	"NFMQdXIITZyodrTvBL/LW9rpyMIQbjUjbPpUteIEsYw2oq5g74vyRLV7UgOkwE1EZ66NCgYWO0pjzRZi",
	"YLFFDjngvTkOFtTObCl9B+K5SeE2RDnogyfLHW/d5vTIEobifadHlvJlb7dpUe3gmGnxJI1bSNkbHCEo",
	"uFb8sJm+ASxc/gJZSbleyU06vcrx581CnDAoHQMgTWMUCgvp4h9UmiwFjinBKSS6mdrx090NOvX+U8et",
	"mtZ727Mdt7D/9jHQOm7JHNvTWOq4e2Gc49qeVcIl6yWNjU6xqrWwcu6LfcsmQse1rIB7TryOa6w+ey4M",
	"SuPvro81nUdp332ZfpRe7bgWLbr/kq/6xrN/wJBJbVflgFB1zgxHG0H6jOs7vf3g5kqFNassZiiNoZOr",
	"rap3oKRRCwWam2KvyvNVef6UyvP4zcSr4nxVnFsUp9CcNMUJ1Xao+jItdOWt+m0vnbmN/m2dcAVuI/5u",
	"CR2l4501oHpLOM/ic9ckQoPcHIR1WdNHgO3l8+TdcmRWcPd2nyADd5iB+AYsIN1NEHbmxRsQKaFpbew0",
	"3teECK/pVuQQdVYg5pqM7+OJwzEAKKEOSh5AjCKn2MhVMP/A51cCYtnNiyF/lThI9exQSB4gcSB/18Fh",
	"mBECI2e9RDF0UoI5x/mcYwW9FRrUGvQWJ3O0aH0SVVY62cs7LrHHSMxnHMEPyRyfDl3VQQuYsvc4S6KX",
	"lexipSGQ4oyEUGCZYObMOTYVJG8nk4P0aO5/10roy3dXx274Z25uuJfuer0+B7PwPIHsHGSu1Dxaa4GM",
	"LTGR7ysvxvVqBZw/NkkC3advVfK+Zp7XDSP0ID5A+XUZyG8fEocuMWGX8ucL/bv8msovn1G4hDESS1GY",
	"UYZXkDhvURJtnFsULgGJKE4cCjbUoUvItQN+gGS9hDHXD2vElk6IKaMdByVhnEUcDoEJ6zgrTNgCLKAD",
	"ksjhBhF1ogxK9w10YpwsnAjGHDAf2BgKr+cSEmeJMwrPFdKpBefJEjpLQB0xCtyAwHy1hJSK5jRLIQFJ",
	"kskQGk4cQcUSpc6C8PGmziyTgkogV9cwsnam2fXHErB/p04CH9n/3sbJP66ct3i1gly+PqEEUQaJM8mg",
	"cx3HkGw461DiMBDfy3ilDJnhVQqSjQNmOGNCPuMHraEEizRvcKK5teLv66GiDiDQmYMQJQsrFReFcCRu",
	"x02z2TQCTEaJgt6ZNzzzgjuvd+l3L7ujc8/z/sftuAwxEUiSciCndJpiKnk9g44SGJQ4wEng2lniFXRm",
	"GyfB63PnQ0IZBBGXl3+nCjdnBpJ7kqUsFKttYajX5wOBMbeepxmJ+URwl4yl9PLiovziRQLX9KKg4SIp",
	"BPmMo3M2y1DMxfFM8u0sBBkVD5U0XPhez+sNR77nflM2r0uEK5phG15qiZ9Dbtl/K23OXJwxt9M4w1Hk",
	"Xr4EGR0XJRF8dC89YxunaMLrhBu/deTybcIcxBRWGFFYx/7QH4/G/WA0buQPt4imucbzqxx76vwIpuYf",
	"mNxDcvByebix+VY/4n23YDPm7BSY3E4m3TNlVkxvCGY4xPHZL3hK4JxOlxBEdLoCKJmCFE3f4jjmojuL",
	"4VWaEvwAYkF5HP86F0vPNnr26ukO38PEferU/TG7eDWOJeqqCLoXW6gvuvNvtRHgItpSn9weSLKV6E48",
	"gUKzPeB7aHSs02GO6DbL+zvp8J1kmCTuepRqQsLtilZFRJHz1O7Al6gwxj0kkC+0HXcm8g/nKBH+dLfj",
	"hiAJYex23CyN5Ctqb8W/tCkdbzJyetFokZefkNLBPwm+dwRE8KecewLzn3zmmTQY826WbbhZA2M+w/B8",
	"DkV+GeQGWj4l88nY5my7IyChvLsfXYKvH8MlSBbwI/ozQxFiG1vApPUFutZrLn4u46TRnVMSDmJb2U/c",
	"YBPkqNSNg2N5bDEMIr4uzDAheM2FU0qSsBNW2mBIhU+b775i/oHvGyMC1sfLbY4fBsnLDj8GxZLvgpU+",
	"JNH+gHOGAgaJtG5PoMusAmT02p4QFTyzGRhaTAjkei0J+W+xkDv5nMJWVJ3GZsLAPW//klKj+iwEJ4UE",
	"4aiOA5TexTkmK8DcS75Fg2d8H+tayBfJdru+Xhlw2bYjOrQNtFAkLyl4ssPWZK7McUPsKAP3nD1Zoj+F",
	"MUCrFuVrDdL6wErnykkWBvwyts6e7PgFP0AipvMNwSmmUo2VmTLD0cZyvEJI5XQW4/De+lSe26r9HKPE",
	"/r4MopYX6NpL5fVVTa5GJCpSjKLjJbdg2O+YwRdRT+UuC+2UH/1TFKGEwQUk0hUFlFepzsHWVYZFhk6t",
	"P6wsMdTHXJz3AAuAEsr1J5hRBlByvPr4BCNkS/2JIqLSIGrwV2gF84zbuoAex4hPRlwHJ7Dt7YDNiXdi",
	"T83J4As/xamAC6fCSffRp4Qud5StdlDf/p0GPN9ZnASyNkBPA5xbH61CtinhzskWoXZhcyX2AAk9wRTN",
	"Qbc/QXPQJ5ieJuwTTM7byaRdgBMcIhCLyHTbbJag38EYti12EnL7giHh3mB6GrgEz1EMTwT6cXMKwLfw",
	"AVF4GshrQKJTQJ4sAWkZZTGZpSl8GmvK6OANQdHidPi3r6kN4O1PSQN4oVG/tWF8F+vWj+6QLy+FPw22",
	"LxP+OvkmvkyPuYn/YaNgVpRrMbAYiR22CIW1sL2u2j0/upx+Lk6yaL5kyX2C14nbcQGZIUZE9R1A1hCI",
	"eAt4AI9ux50BKuP2wqg+oytA2Fm4BCgRv7IQi08hwZTOZJzRKOYzByQElImw4yLBFFExFAkEbsddAcpw",
	"JPwtCQT8FZwytEKUt0xxvFmIZ4TSZTbjYwce+JMHGoujDTHYCLizOIP0flMfVeP8Q1E84fxzXkShOB2B",
	"VimWzm9RvOXSXSC2zGbnIV5dEEq7Z6rxRarZvMBqRC8So6jQ3tZt3UOjk14N72L5DZkKu5OLpuqFLGVU",
	"WVxARULkrkEDlRzZvsOobKmfZnZVDOBjp1hpB/ATYXzCdfYk+N6opcg2caYZia2i3RgcUNmO04wg6/Ml",
	"SCKriHfclXayth+ol/5byxRO5bZq2hC1SLOZTthseoXIrchJokc0W60AsTOagcWeQRMGyAK2a3VMyyKp",
	"umiUmtKJuFwjooQNeoU2NOIZJ1aHek/9EtGcUo9GjsKWCMIMYXv87TFFUih2W1S2TDm0AgvYOFfvoV30",
	"GpbMZ2fTA4iz0w/n1mSGBK5FeHlNRBG9PElSfD/ajjX9KS8qVI9GwlNaSPXJfFC8k8fNtFl62xvSx401",
	"7RmjxEhnamnklMPqJ1q8b/PV52fBWDrYfg6EGUgixV4ter/lu7zr27dnohoe/+AP+urTMPD1b35f/+iP",
	"B0O3436+vjnze/7x4nqno/m7x6MjGKIViKk9cwBFOy7JzbofEAqjqV5R7AYANTja3qhroLyDzWqG7X2r",
	"VS6nkX/vbFmknmXG0TrO5hh+iWXD0m+xfMhTrGb1xdb6NYtwSEPx1L2cME+u9aF/idM99UjBC8ub7PVV",
	"2v4yaSsNgCFrEUwxFQVc28sDrwaOfnSnbjUW9RPh+9M4zqevXqdXr9Pf0OuEU5gILquM0JazNjV4jmCe",
	"btZeML0E3lA7J+pBDu+JgBs5kCfqQe8RTwM9D5aeCP7tZKLKn50CepFQaGZiHGBgaKjcgDFqExomjQik",
	"yuoZFMbz5wKa+nKHx/N3RjV+W1DTuBJBNHA7B8Q5QV4g7GCqX4PQP1QQujQ2d7LOYX1cQkP9dFyoVXXH",
	"XRQzQxZukpO8o+qlUKkTOy4z1O+30qU/BaxtPGNgcX4HFq3xioFFXip9h9qIxyvt2g5ZsGXGdxgddyX9",
	"wkykDylmyWPaIKvW5jhC65TXWQOjOE98F96ue8l/dWdPjEGb/Ru61MAg1YngHfcBH1v0oWHlKaUDbeV7",
	"e73rdck87wNh1GIPyuwwI0cqYaLjRjIPISc0xSL/SQdbVEREumqQnLbSRO+4VHi820PTtL8a5oL07Vgm",
	"RduDok0di6qzdfJs+aVamVdZp0i+4VBGspBlBMrLi5wYUVa+uOZcjoSljlIdrL31XnVizSqf1Y3PvlU/",
	"jYuHatuMWu3oGkEfc2LkG+YNPpU6sCaRKWAMEg7g/3mPX8DZ/OrsvXc2/va95z39mzVD6cCiw6Xi1bZq",
	"vimBlPPGAYmDkgg9oCgDsbqhSl/CBZL8Dq76SO9yitdazNqskrjraIn3K2Whd2l7o99/qlajq7LkKhfQ",
	"324/Uke9rGscguI+KT2Wz0U26jvzfUox73aaOW+AzcrNu5dc3i78ReFzwa05yGLmXvpep80L3UqXoXnc",
	"on1EK67aAk9oUvnFr3kODp0MN/mlbZqeE3TzoCqxGIVELfVDxV2eV4M37+Vdnu/H74bwWtzleS3u8nzX",
	"HYIrfZdnqbaoDjy63uNwPOi9GVyNwHUfDP2eN4bDa38I+rNgMBiPve5VMByPh1eha8Yk/VF+tcpNDDbv",
	"sLxmLg8XFtFWHeFzbz5e/bebx+tc37P+q8+zouqj2NPQECTnCF+wx4sW7gjNqz2aVrqqaug9wvnb/nw4",
	"DPtX7/rv3oz6szAYDa9HXjQKu29Go7A7D4aDQfC2mL3MPLYQgjjWHJ9nibw7YAnoUgDveUEwG/Zhpbi/",
	"rh8J5aCrmihu1+8PxuNxv98NvPHAKwaDj8VTp5CIN1dvepE/D4azq6vhcBCAXjQKgjcj7+2gN3w/9Pvj",
	"IOiNg7muRdnSRav1WpPGDlQXnNxLXvNilPL+SOswlWpSjgaj8TAY5qO3h2BX61V6lgHtWANv9HlbpUGH",
	"HWS84MS2MpiCtlP9Sf3+0fdKKDHdpd17KET94FXfdsEwZ3WWoD8z6KAIJgzNEST5tQImp+updFJkbRDF",
	"Iz56pSVHDR8f2XN7qsVu4UrLFRdqfthwEY+quFgJOsayabzW7UMSoVDUa14vxYQu86RaiTRHa4ZxDEFy",
	"oNly1F0Xexs95blvGwTxym6WiV00WjasMrbkwi5DTtYbbiClU5UOultBWlF9XtwAvL3vt4aqadwSiGrW",
	"II4d/qYDqPCFMV0jfPumoLxO2kaDP9EzQr8uuoORfWLITCf9qh2ofKmAx40bKzQC1g27XrB2tCI+t5aM",
	"amZqqR5wpX58+VrRL9+l5pqqsjK+P+wpZQajKWXi+Erg9fzByBs1LMdGxe3fJx9VViaDldZjYc+xjIqx",
	"BRHfPspw4peqT3MtCim7l8otLL+KUGje7VmI1TndEvqB3x31+sMaBf3xeNjrjromBYU32iDgbUZUxo1J",
	"gmw+DraQYHpfG6gJFWyTHoXEmXxWo2cwHo5Ggxo5fm/Y7476JjWFk9+g5hMSlxdUyZHNB1uoUd5mE/uV",
	"hmWir3o9Uw+5lWpc0KqFq0C8ZNEZsQIDZ+PXMtbenvgWcEyM9c9KgL5J//rldkylC95AskgD3R1HDsRE",
	"UMVAnmqW4DM3/3LlUHrFkSDN61D3sQOLsuU2W3DLfbsckfzxSZEg9CBA23WksUTVq68/c7QP0WlR6Oq7",
	"xUppOjvRlFxQrOn7HJsolTkzUOroC1ll27J/5Ns2rhx1Fbu1DmLN9m4/RakhFmzcC0Cn10kkHCRy3O3C",
	"DNU7jipKJ64XCUUDJxKSQrWhIKW9bm8sGUuDaYQomMUwOsxe6ggogkBI6KEwVDpMu+Zafv9S7Z4keS+S",
	"dtXXGRPiCDZwXbTkz+3G7gpSmvvI7I3VK3uaSe8h3Gp2ziHfu0m3KrfhRNBhm7Fp5N/XMVUPHYad9RKF",
	"8o4W0QV1UoDstmZRw9YCUDzLLVdoty9zt07DMsIfOimBIaLiSpscmoJ/vmPme/myx7J/dg8HrQpTNPhj",
	"A9MfK+C26ik1wjA1dmmnv6ny5LVPMqJlkfgGSHeFDtWehQQ+ModCMZgE0ixmdE9Zrtwb14w+kjtwfRFQ",
	"dSua8uZ1WtgW0HdNYBzwAFDMFeG+QmTWNzxBOqsRwPleyo3QPu3z/I22siRWRsxoN7GsXch1FUVIvulo",
	"aM1RoWbWyglzq64rq5s+YZpNhW1shpTmMQasACsHWrr76P2UpiCEU5RMFzP78aIma2gFV5hsipbP97dP",
	"cmbVM3ZiwyN3wH2r973N6lCGc8XOmG0cOUKWkHZ1f3DIVbhVc2Gr3X+KDpRNXyuxLWbBVHJj5z4r1l1z",
	"HWK1FdwTvNxUaOCW+5Welz7jQkbbhX42y7GyZuJVYaFSZwU24ppBcXsaYc5/3d3dBB2xiLAlEisoVyP8",
	"r4IpXxE7M3P3ou/mKrYwRVQtyeLYYo6WEeNgHfVU3eHG7SfpnFN3TEl8OF6agmfwWIH0ixy1b3kWWxkp",
	"Zd/W59Nvtx+1GdPYmYoByb44pDJ0y558j3BIec7vIRwNm9G/YFIcsHcveqndhtFMvrr9szIlQvwAiTD5",
	"/Y7LOQEYlvG+LghHXtfreqEH52EwDvvz3mjQm/d7vWg+m/d8PxwNwmAoUnL1XbLupfv9q/bmTBmOIQFJ",
	"CL+6l9+/5nmyX4VB6XW+ap+W/IF/fwCP+ZcZoMUTSwJt/ixPnv3qXvbFL9p1mb+SJ9J+dS+7AxGu7nxV",
	"KbX5SyKxNv+mk2nzH5T/MP9OwUPx8IHG8vNTp6DfqJ1e58CoPwx642FQZkN32OsODFb0gq7n94cmP/zA",
	"H/SDYSNTuoP+oNsf9KqcGY16g8HQr7Bn3O32gqDEjW4wGPfHo8BgSdAf+35QZYs/GPn+yA9KzOn3fK87",
	"8voFhwbesOcXPOr548DkEreApmpeGDZOCsl0hRO2rLEuGJR4ZnCrJDbNUuMPK7ypyEzfN9kxNvjQ9css",
	"CPplweh3DcEoSK5IYN97ehL+zBCTSMz9GFDG1T5hM8itMn8Y8H8jbyBegwmbavXuXn5xL0p2yYX3OOwN",
	"+/71sOcDfzy4Bl50FVz1QTB71x1eRe/fvO0OejC89mZup9o2v6D8m9HTGgi8vnx3YYrDJZfWnlYPCCfF",
	"G66nLjaHlE11wpzr98R5H5WUa7w98PuDwWA49H2v1x0H3ngwHvvdntgc5D119+nJC0bbevL6Ay6NPS/o",
	"dvuDYFjuKWivp0HQ7QWjYc/vjfgUHvnlnvw9euqNtnXU7w+H4+4w6AWDoTcYDAfljrzWOuqNhuNgMPA8",
	"rm16wXhc6mg43qMjr7kbv98desPxaOSPgy7/1y93M9pL7Jo76o6Hvt8fjb1+4A+Go8GgV5a64XCPjvqD",
	"Lf30B/7YH/T6o97IHwaDoNLPYK8B2tJPb+z3esNg1PU8rx+MBqNyP/09+gm28K03Dnqj/qjr9/wgGPpd",
	"bywiOTQGdAmjqb7zyxXpX1kqKiNdBr3xmEvIAyRU+aFDvBLeKlcli+m0IO/cO/cskZnCMLEZnsoUL2Ih",
	"OmtHuHiUfzO3rBo3go2h4uoOqrCMrJke6qkDH1a587GCjC22nRtNDX4rwm17tUwaF/Y/C9pYWHYxKm/V",
	"68YANjue5BsNKBh+CGPod8Hhd/X6Tjas3todsW/Q1vDW/m5KQ1RxQKfo8DSNjjh+XU4E2SmPrNzqqeMK",
	"43I6AyxcTin6JzwUHwmHGwAoZbQ1gPnVXIeD2O1UcxOMECdqIk01idqMOgxgiywiMAabaUbiqSjx23oE",
	"6cZIKwPJZgdvnG6pw+/TdyX/13PnVGvN3+eerZKn7rbQT7YjKOIh1zBcu2w9cVI1m635nIAyJ39Hg7Ur",
	"rZqp3YAg18u5u8WAuGXF0TeAK/exJC1FO60+Vbt8K1biHStSu60Fqtx//SKwyopvXZblO458x8LrXXzI",
	"RaE1G5X8mQm44r+R5o81fMkfyagPh2EXAL2Sb+d1vt4b3K5BNZfjsr21TTzUkaLtAGummnUs5Es74bht",
	"OCZNCaa3ljNPfPMdOTjRqaUqR6WeXapCM+ogwkS+ZfSqDvWeMoggUla/lfvckUwdTKQiuIq4xIPFf9D/",
	"3He26azZ40563ZlJtxa7TT/mIrBewsp5HByKBdI2IcqnmTNZx8PsGO8Rf1fHyxB1ZN56Q8pnKZf2dBKQ",
	"110wKZTQzu9kQk8r0cg9gpAG8b8XxnOduwvEHGVdi5yJZm2o91xNUOTzLWo6TwG3t2dgcaCO/0Nl5u1r",
	"mCg34WFmiWrcYJSUXOuNgYFDbT10cIISSud0ugAMrsHmYKtV5W5MiRGL3un8ZSWEvf9ZiSom5W3vTqcd",
	"ihZPRU5n28aykcxY0jqVKwwOPihy1BkPlee6T4yoWFJ1IakdF6QDuKxm81Mp/XeL2+XDO5u62HUay95u",
	"CF6IDLB69oayflhmSSF8ZvxzqDUFUMoVbz56FOpEsVqXZgnYcv5zIzQYCTrgc/DKidF285K/sQu05+fI",
	"JJfGxgEuMpPrxXw/cMpklFmnbf+WLCGI2fLZIjQK7Yk2Kg9YovlipTOF1rnc7mtyNWyQrdWLfZSES7fj",
	"Xl39fs3/gAe4wCxcIv6lKB30RlYKegOT6N3Vr27HfYvX/H+jMpA+MXH9eeJ23PdGcaD/QotljBZLxhn8",
	"f/9A9xz4/0FrJCr2uh33I9+zddyPKMLijywh9BF9vr665R8wvqe3gHDon0ShAv52fqbhMwRkoqvifMaZ",
	"gPVrCpOJAPNrUXeIK+sFAelSfVblWG5wvFkBcg85gtxY438ASmaCxsnV75/4HwbIQhaJ/y1BqqU85vI/",
	"kFgLypTFoxTZOs81aEtyUg6cHSU1782Mn7rEfNLnKZ6hN08cap/WIifpADqtVppZP0WVyDJnglFES9fM",
	"gkkUASwKOQnBDIWwmKWy9DEfKdxLYxKgP9dyEtyjNaJqEsTyvVhOAl1HS/wlomYQvqdEToJVPgnywzgr",
	"vML3QFXbymtEJWo26FnONxhUwDWrcRmzIi1mRWrOCpJPBz42Rb0uWsyKLJ8V8rTWPw+YFWqt/mHmRM0o",
	"L9UEslXzaZoDLVN2wAzgZMEwI4htJhyWut0fAgLJVcaEY0p0Ijwh4udiBV4ylgoryEXKCK34ISaTrvMZ",
	"R9C5uvnQkecz/8wg2TgUkgcUQuqkBD+gSG2sZfamq1u4RkjG9WXQTUorSJF76XbPvfOuKq8n0L7g/ynP",
	"e4NHRDgxlaWlkinPXSPu+CFyL91fpHTr5G0OLvA8uT0VpWRFnhR8ZBdpDFCS8wiUi+bcLRF1kKhZU3BC",
	"9gQjZ7ZxvMcv3tlY1tURRXXsNmaFls82Ep46bk+iaLNHc1KKT9M3ILqVHjzeuL9f4w9chBIQyxMfT2Zd",
	"WM49Seqv2ucotijFUTfx9RtvlNc5LKzUHYavZLFtHUVd3OStgP7skII01aV1L/5BcXVgK46KRrPadmbh",
	"vFQ4JugF3jgYeCObaSwiBPLumWhLfEDENEtuMWnIrwF1VGve6S63AFlSVmtSd1XuRZ+/iIwT+fHmx5TD",
	"HHUtBhZBbMgw4sOualE3uVgdEVWrnFCpnkJfZTFDaWy6X/NaXOpMf/nQJt1QBlfnzn/jzAlB4mQUOg+A",
	"IJxRpUKN4DrDzhzFDBJxJE0fPxFQ1XmRjoOSMM4ilCycGK0Qow5Omg/YcDCq7ECncMbSTsVH3nHyeh4d",
	"0WaFCaxPxBtMWcmwyguV5YEGXd7NPu76FQTNb5vpG875X6AdeFFDrlRbzpj5uwpZvRrdDyDmatEWDh9z",
	"uf7yTeS65LNA8Mjhc0EzxjE4U8yFsuVrmxTa8PiuPjw9r65tRficOcGrSiiiLPu6bqtzZ6aEOyCO8Zo6",
	"G5yZAm8Ecjb5DDHmBs3CpQOolHpDmOuy3CzAVRFTPrKirqzpIWxwCxevGB+n3HTJb55o8ibZmwotMBVk",
	"HdRSzu8jAKgTbIc0pSgJ4ZQZhVT2h5ElDMVHwtCVaA5pGxnlgvZvLeviHtBuW/HtbQ3zjXxl+/Pth9ON",
	"Pa+3T+PPmL3HWRK9rFoVxoVKcztQn+oRufiuP51Mo+oOflyVqr1BhlfoOKXaJO+vOvZVx55Kx+YL+atS",
	"PVipagVwqFZljxffUbSDJtVHaeuJMfmGWgb9tiuuu8cP745WVrkbBEV/jZ5RAFKwgG1J7+bvJ7u5o2HG",
	"ZWcvsf2u3AHNglteubX/hZouIJvnAdRdDv/6HocGn0AL81TCebUi/j5WxDG789dd3r+CUpdKc2d7JI/C",
	"/SVu5KLk3r+aCzmPt7btPq4BfnUd7+U6LgLh1QlwQpdxIec/ors4Z8mrq/jVAPlpXcVGPsmrAXEaN3Gz",
	"7jype7jQnj+kazjnyuncwmau1KsufdWlry7hn9Ql3KxBX8AVnHf+6gZ+dQM/6wZuFtW/wv37r+kpsOzn",
	"X92+r5bC38Tt+7pjO7nLt6rElaDQizA/h73d2ihXdDYvkzAa2PPZ1VaSqiPfx41wqbrsD+SeLA2FlVn2",
	"FG5d4oRe6NMo7RwF0ccYqDrGcBTPVRGvH5XdIl8+P6u6lclyZOi0OOnd6tGNnOvyjBTNkTqG/cWJ+R96",
	"ACSaW8eBUHrxnRsn+2xv6n6g28nE4VCsQ3A7mRxtOhF13P2YUbudTP7OqxEfI3NLcQPY0hAKPkrfxIEd",
	"9UujHMicj/yiIg63fEBJlTbiELkVshuYchaJFWC99sluoIsdihVsqSrK/w8AAP//5w+8/CTvAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
