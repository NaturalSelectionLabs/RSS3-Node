// Package docs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package docs

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	"github.com/rss3-network/node/schema/worker/decentralized"
	"github.com/rss3-network/node/schema/worker/federated"
	"github.com/rss3-network/protocol-go/schema"
	activityx "github.com/rss3-network/protocol-go/schema/activity"
	"github.com/rss3-network/protocol-go/schema/network"
	tag "github.com/rss3-network/protocol-go/schema/tag"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// PostDecentralizedAccountsJSONBody defines parameters for PostDecentralizedAccounts.
type PostDecentralizedAccountsJSONBody struct {
	// Accounts List of accounts to retrieve activities for
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   int               `json:"limit,omitempty"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag     `json:"tag,omitempty"`
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetDecentralizedNetworkNetworkParams defines parameters for GetDecentralizedNetworkNetwork.
type GetDecentralizedNetworkNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetDecentralizedPlatformPlatformParams defines parameters for GetDecentralizedPlatformPlatform.
type GetDecentralizedPlatformPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetDecentralizedTxIDParams defines parameters for GetDecentralizedTxID.
type GetDecentralizedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetDecentralizedAccountParams defines parameters for GetDecentralizedAccount.
type GetDecentralizedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostFederatedAccountsJSONBody defines parameters for PostFederatedAccounts.
type PostFederatedAccountsJSONBody struct {
	// Accounts List of accounts to retrieve activities for
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   int               `json:"limit,omitempty"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []federated.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag     `json:"tag,omitempty"`
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetFederatedNetworkNetworkParams defines parameters for GetFederatedNetworkNetwork.
type GetFederatedNetworkNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetFederatedPlatformPlatformParams defines parameters for GetFederatedPlatformPlatform.
type GetFederatedPlatformPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetFederatedTxIDParams defines parameters for GetFederatedTxID.
type GetFederatedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetFederatedAccountParams defines parameters for GetFederatedAccount.
type GetFederatedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostDecentralizedAccountsJSONRequestBody defines body for PostDecentralizedAccounts for application/json ContentType.
type PostDecentralizedAccountsJSONRequestBody PostDecentralizedAccountsJSONBody

// PostFederatedAccountsJSONRequestBody defines body for PostFederatedAccounts for application/json ContentType.
type PostFederatedAccountsJSONRequestBody PostFederatedAccountsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Node Operator Info
	// (GET /)
	Get(ctx echo.Context) error
	// Get Node Activity Count
	// (GET /activity_count)
	GetActivityCount(ctx echo.Context) error
	// Batch Get Accounts Activities
	// (POST /decentralized/accounts)
	PostDecentralizedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /decentralized/network/{network})
	GetDecentralizedNetworkNetwork(ctx echo.Context, network network.Network, params GetDecentralizedNetworkNetworkParams) error
	// Get Platform Activities
	// (GET /decentralized/platform/{platform})
	GetDecentralizedPlatformPlatform(ctx echo.Context, platform decentralized.Platform, params GetDecentralizedPlatformPlatformParams) error
	// Get Activity by ID
	// (GET /decentralized/tx/{id})
	GetDecentralizedTxID(ctx echo.Context, id string, params GetDecentralizedTxIDParams) error
	// Get Account Activities
	// (GET /decentralized/{account})
	GetDecentralizedAccount(ctx echo.Context, account string, params GetDecentralizedAccountParams) error
	// Batch Get Accounts Activities
	// (POST /federated/accounts)
	PostFederatedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /federated/network/{network})
	GetFederatedNetworkNetwork(ctx echo.Context, network network.Network, params GetFederatedNetworkNetworkParams) error
	// Get Platform Activities
	// (GET /federated/platform/{platform})
	GetFederatedPlatformPlatform(ctx echo.Context, platform federated.Platform, params GetFederatedPlatformPlatformParams) error
	// Get Activity by ID
	// (GET /federated/tx/{id})
	GetFederatedTxID(ctx echo.Context, id string, params GetFederatedTxIDParams) error
	// Get Account Activities
	// (GET /federated/{account})
	GetFederatedAccount(ctx echo.Context, account string, params GetFederatedAccountParams) error
	// Get worker config options
	// (GET /networks/config)
	GetNetworksConfig(ctx echo.Context) error
	// Get Node Status
	// (GET /operators/info)
	GetOperatorsInfo(ctx echo.Context) error
	// Get Node Worker Status
	// (GET /operators/workers_status)
	GetOperatorsWorkersStatus(ctx echo.Context) error
	// Get RSS Activity by Path
	// (GET /rss/{path})
	GetRSS(ctx echo.Context, path string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Get converts echo context to params.
func (w *ServerInterfaceWrapper) Get(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Get(ctx)
	return err
}

// GetActivityCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetActivityCount(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetActivityCount(ctx)
	return err
}

// PostDecentralizedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedAccounts(ctx)
	return err
}

// GetDecentralizedNetworkNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedNetworkNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedNetworkNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedNetworkNetwork(ctx, network, params)
	return err
}

// GetDecentralizedPlatformPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedPlatformPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform decentralized.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedPlatformPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedPlatformPlatform(ctx, platform, params)
	return err
}

// GetDecentralizedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedTxID(ctx, id, params)
	return err
}

// GetDecentralizedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedAccount(ctx, account, params)
	return err
}

// PostFederatedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostFederatedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFederatedAccounts(ctx)
	return err
}

// GetFederatedNetworkNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedNetworkNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedNetworkNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedNetworkNetwork(ctx, network, params)
	return err
}

// GetFederatedPlatformPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedPlatformPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform federated.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedPlatformPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedPlatformPlatform(ctx, platform, params)
	return err
}

// GetFederatedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedTxID(ctx, id, params)
	return err
}

// GetFederatedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedAccount(ctx, account, params)
	return err
}

// GetNetworksConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworksConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworksConfig(ctx)
	return err
}

// GetOperatorsInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetOperatorsInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOperatorsInfo(ctx)
	return err
}

// GetOperatorsWorkersStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetOperatorsWorkersStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOperatorsWorkersStatus(ctx)
	return err
}

// GetRSS converts echo context to params.
func (w *ServerInterfaceWrapper) GetRSS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRSS(ctx, path)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/", wrapper.Get)
	router.GET(baseURL+"/activity_count", wrapper.GetActivityCount)
	router.POST(baseURL+"/decentralized/accounts", wrapper.PostDecentralizedAccounts)
	router.GET(baseURL+"/decentralized/network/:network", wrapper.GetDecentralizedNetworkNetwork)
	router.GET(baseURL+"/decentralized/platform/:platform", wrapper.GetDecentralizedPlatformPlatform)
	router.GET(baseURL+"/decentralized/tx/:id", wrapper.GetDecentralizedTxID)
	router.GET(baseURL+"/decentralized/:account", wrapper.GetDecentralizedAccount)
	router.POST(baseURL+"/federated/accounts", wrapper.PostFederatedAccounts)
	router.GET(baseURL+"/federated/network/:network", wrapper.GetFederatedNetworkNetwork)
	router.GET(baseURL+"/federated/platform/:platform", wrapper.GetFederatedPlatformPlatform)
	router.GET(baseURL+"/federated/tx/:id", wrapper.GetFederatedTxID)
	router.GET(baseURL+"/federated/:account", wrapper.GetFederatedAccount)
	router.GET(baseURL+"/networks/config", wrapper.GetNetworksConfig)
	router.GET(baseURL+"/operators/info", wrapper.GetOperatorsInfo)
	router.GET(baseURL+"/operators/workers_status", wrapper.GetOperatorsWorkersStatus)
	router.GET(baseURL+"/rss/:path", wrapper.GetRSS)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
