// Package docs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package docs

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	"github.com/rss3-network/node/schema/worker/decentralized"
	"github.com/rss3-network/node/schema/worker/federated"
	"github.com/rss3-network/protocol-go/schema"
	activityx "github.com/rss3-network/protocol-go/schema/activity"
	"github.com/rss3-network/protocol-go/schema/network"
	tag "github.com/rss3-network/protocol-go/schema/tag"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// PostDecentralizedAccountsJSONBody defines parameters for PostDecentralizedAccounts.
type PostDecentralizedAccountsJSONBody struct {
	// Accounts List of accounts to retrieve activities for
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   int               `json:"limit,omitempty"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag     `json:"tag,omitempty"`
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetDecentralizedNetworkNetworkParams defines parameters for GetDecentralizedNetworkNetwork.
type GetDecentralizedNetworkNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetDecentralizedPlatformPlatformParams defines parameters for GetDecentralizedPlatformPlatform.
type GetDecentralizedPlatformPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetDecentralizedTxIDParams defines parameters for GetDecentralizedTxID.
type GetDecentralizedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetDecentralizedAccountParams defines parameters for GetDecentralizedAccount.
type GetDecentralizedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostFederatedAccountsJSONBody defines parameters for PostFederatedAccounts.
type PostFederatedAccountsJSONBody struct {
	// Accounts List of accounts to retrieve activities for
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   int               `json:"limit,omitempty"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []federated.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag     `json:"tag,omitempty"`
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetFederatedNetworkNetworkParams defines parameters for GetFederatedNetworkNetwork.
type GetFederatedNetworkNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetFederatedPlatformPlatformParams defines parameters for GetFederatedPlatformPlatform.
type GetFederatedPlatformPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetFederatedTxIDParams defines parameters for GetFederatedTxID.
type GetFederatedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetFederatedAccountParams defines parameters for GetFederatedAccount.
type GetFederatedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostDecentralizedAccountsJSONRequestBody defines body for PostDecentralizedAccounts for application/json ContentType.
type PostDecentralizedAccountsJSONRequestBody PostDecentralizedAccountsJSONBody

// PostFederatedAccountsJSONRequestBody defines body for PostFederatedAccounts for application/json ContentType.
type PostFederatedAccountsJSONRequestBody PostFederatedAccountsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Node Operator Info
	// (GET /)
	Get(ctx echo.Context) error
	// Get Node Activity Count
	// (GET /activity_count)
	GetActivityCount(ctx echo.Context) error
	// Batch Get Accounts Activities
	// (POST /decentralized/accounts)
	PostDecentralizedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /decentralized/network/{network})
	GetDecentralizedNetworkNetwork(ctx echo.Context, network network.Network, params GetDecentralizedNetworkNetworkParams) error
	// Get Platform Activities
	// (GET /decentralized/platform/{platform})
	GetDecentralizedPlatformPlatform(ctx echo.Context, platform decentralized.Platform, params GetDecentralizedPlatformPlatformParams) error
	// Get Activity by ID
	// (GET /decentralized/tx/{id})
	GetDecentralizedTxID(ctx echo.Context, id string, params GetDecentralizedTxIDParams) error
	// Get Account Activities
	// (GET /decentralized/{account})
	GetDecentralizedAccount(ctx echo.Context, account string, params GetDecentralizedAccountParams) error
	// Batch Get Accounts Activities
	// (POST /federated/accounts)
	PostFederatedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /federated/network/{network})
	GetFederatedNetworkNetwork(ctx echo.Context, network network.Network, params GetFederatedNetworkNetworkParams) error
	// Get Platform Activities
	// (GET /federated/platform/{platform})
	GetFederatedPlatformPlatform(ctx echo.Context, platform federated.Platform, params GetFederatedPlatformPlatformParams) error
	// Get Activity by ID
	// (GET /federated/tx/{id})
	GetFederatedTxID(ctx echo.Context, id string, params GetFederatedTxIDParams) error
	// Get Account Activities
	// (GET /federated/{account})
	GetFederatedAccount(ctx echo.Context, account string, params GetFederatedAccountParams) error
	// Get worker config options
	// (GET /networks/config)
	GetNetworksConfig(ctx echo.Context) error
	// Get Node Status
	// (GET /operators/info)
	GetOperatorsInfo(ctx echo.Context) error
	// Get Node Worker Status
	// (GET /operators/workers_status)
	GetOperatorsWorkersStatus(ctx echo.Context) error
	// Get RSS Activity by Path
	// (GET /rss/{path})
	GetRSS(ctx echo.Context, path string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Get converts echo context to params.
func (w *ServerInterfaceWrapper) Get(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Get(ctx)
	return err
}

// GetActivityCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetActivityCount(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetActivityCount(ctx)
	return err
}

// PostDecentralizedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedAccounts(ctx)
	return err
}

// GetDecentralizedNetworkNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedNetworkNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedNetworkNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedNetworkNetwork(ctx, network, params)
	return err
}

// GetDecentralizedPlatformPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedPlatformPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform decentralized.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedPlatformPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedPlatformPlatform(ctx, platform, params)
	return err
}

// GetDecentralizedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedTxID(ctx, id, params)
	return err
}

// GetDecentralizedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedAccount(ctx, account, params)
	return err
}

// PostFederatedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostFederatedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFederatedAccounts(ctx)
	return err
}

// GetFederatedNetworkNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedNetworkNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedNetworkNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedNetworkNetwork(ctx, network, params)
	return err
}

// GetFederatedPlatformPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedPlatformPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform federated.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedPlatformPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedPlatformPlatform(ctx, platform, params)
	return err
}

// GetFederatedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedTxID(ctx, id, params)
	return err
}

// GetFederatedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedAccount(ctx, account, params)
	return err
}

// GetNetworksConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworksConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworksConfig(ctx)
	return err
}

// GetOperatorsInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetOperatorsInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOperatorsInfo(ctx)
	return err
}

// GetOperatorsWorkersStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetOperatorsWorkersStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOperatorsWorkersStatus(ctx)
	return err
}

// GetRSS converts echo context to params.
func (w *ServerInterfaceWrapper) GetRSS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRSS(ctx, path)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/", wrapper.Get)
	router.GET(baseURL+"/activity_count", wrapper.GetActivityCount)
	router.POST(baseURL+"/decentralized/accounts", wrapper.PostDecentralizedAccounts)
	router.GET(baseURL+"/decentralized/network/:network", wrapper.GetDecentralizedNetworkNetwork)
	router.GET(baseURL+"/decentralized/platform/:platform", wrapper.GetDecentralizedPlatformPlatform)
	router.GET(baseURL+"/decentralized/tx/:id", wrapper.GetDecentralizedTxID)
	router.GET(baseURL+"/decentralized/:account", wrapper.GetDecentralizedAccount)
	router.POST(baseURL+"/federated/accounts", wrapper.PostFederatedAccounts)
	router.GET(baseURL+"/federated/network/:network", wrapper.GetFederatedNetworkNetwork)
	router.GET(baseURL+"/federated/platform/:platform", wrapper.GetFederatedPlatformPlatform)
	router.GET(baseURL+"/federated/tx/:id", wrapper.GetFederatedTxID)
	router.GET(baseURL+"/federated/:account", wrapper.GetFederatedAccount)
	router.GET(baseURL+"/networks/config", wrapper.GetNetworksConfig)
	router.GET(baseURL+"/operators/info", wrapper.GetOperatorsInfo)
	router.GET(baseURL+"/operators/workers_status", wrapper.GetOperatorsWorkersStatus)
	router.GET(baseURL+"/rss/:path", wrapper.GetRSS)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9bXPbOJPgX2Hxtmp3q2SbpChR8pcrJ3FmU5dkfJZnpnaTnAoiIQmPKYJDgJb1pPzf",
	"r/BGgiQo64XKOM84H2JJJBqNRqPR3ehufLdDvEpxAhNK7MvvdgoysIIUZrVv0xTQ5RSEIc4Tyh5FkIQZ",
	"SinCiX1p30KaIfgALRBS9IAogsSaZ3hl0SW0SApDNEcwsmT7c7tnI9aMAbV7dgJW0L60FfSencE/c5TB",
	"yL6kWQ57NgmXcAVYt/ARrNKYve08RqMIDGdzbzge+mA+jgIIozF0+nDQ991B1A8AGA8df2D3bLpJWRtC",
	"M5Qs7KennmFoHPHNFEVbhhdBClBMrDnOGkMT7a0P7+xeBc2R70DfiwZBH86gO597ARhDf+z6g6A/86Ez",
	"cEfzMBqOBmEwH/f7btR3x2AGRwN/Howc2DcTC0Vb6fT8gBNI1zi7P3guZfvzymghXcIM5iszzqrLbYj/",
	"Wwbn9qX9vy5KvrwQT4u/05sMUxzi+LOEZxpeGgM6x9lqGsEQJjQDMfonjA4erQJXHe5vCSJrkJpHq5oc",
	"P1wJ6F1lJFsHPYcRzAD9yQf8vhiFabAZIQet1NvJxJKIlwMDs7BlUOLbgSvtzxxmGy5bcDKN0QoZZOeE",
	"Y7bhWCb5agYzC88t0YZYa0SXKOEPCxFDsZXJcVanx3XUIHjHumjVMNh3Oq5444+87bbxpWABtw8vBQuU",
	"APaAz4scoz4Edyv+vIfD0L9hTY3Yh3lGcLYdcfGOlRMYcczLgZy3UFxC3RfZt6KZEdEIZTAUyO2yqGeA",
	"YYsTq2jXhmsJ+FBJ/K6AYMR8b86XQ2hldK+N0Q/j8C283dE2+R/kP9uoX+6K+yEtdz9ixvtE+9+WcWji",
	"vxwIonBFjtzoCvUNZBlgHT6eLfAZ++2M3KP0DPOxgPgsxSihMBMyejtVutsgfwhFtJ2wQ2oQlIRwStEK",
	"EgpW6W6kIBRkFCULRRNErAJCGyHqHe3L6ndFS/M48jCEW7UBk1iUrdiAaE5aUZew90V5Its9yQmS4Ca8",
	"M9s0CgoWOzJjQ6WhYLGFDRngvSkOFi2CRXDfgXhuUrgNUQZ6b0w3KWxBNU8oivfl7zxl285ufF3v4Bi+",
	"fhJKJiT0DY4Q5Nxc/rCZvgE0XP4CaUU4XgmTmVwV+LNmIU4oFGY6SNMYhVxTufgHEapDiWOa4RRmqpm0",
	"v8nuipV8/6ln11XcvfXKnl3qYfsoSj27ohYdqLT07L0wL3DWtIP9tuxeuTl0sAEx9vzrNtqebdhI9mT/",
	"nq0J8T3lqxScu4s1Nc69BEzPNoiT/TcvSWE8+wcMqVj29dnna96a4WjDReiMLXylB7ONtyZiV3lMURpD",
	"q1i/dXO1IlpKSVIoFa9S5FWKHCFFjldOXyXIS5cgXISQFCdEaSbyy7QUGrfyt72Ex7bxb+uESTLT4O+W",
	"0JLCzloDorT8eR6f2/ogFMjNQVhXRV4E6F7eKNYtQ2YFd2/3CVJwhymIb8BC6rvPMsLOtHgDIsk0nc2d",
	"wvs6y7g/aytyiFgrEDNZwkyzzGIYAJQQCyUPIEaRVar2Ncw/MCmSgFh088OQv0osJHu2CMweYGZB9q6F",
	"wzDPMhhZ6yWKoZVmmFGcrTlajrc2BinP3+JkjhadL6LariF6ecc49hiO+Ywj+CGZ49OhKzvoAFP6HudJ",
	"9GM5u9xgM0hwnoWQY5lgas0ZNjUkbyeTg+Ro4RFVQujLd1t51dlntuHbl/Z6vT4Hs/A8gfQc5LaQPEpq",
	"gZwucSbel3bt9WoFrD82SQLtp2/14X3NHacfRuiBf4Di69IT3z4kFlnijF6Kny/U7+JrKr58RuESxohv",
	"RWFOKF7BzHqLkmhj3aJwCbKI4MQiYEMssoRMOuAHmK2XMGbyYY3o0goxoaRnoSSM84jByWBCe9YKZ3QB",
	"FtACSWQxnYRYUQ6FQQ+tGCcLK4IxA8wmNobckbWEmbXEOYHnEunUgPNkCa0lIBafBRgxkED4j1hzkqcw",
	"A0mSi8MNnFh8FEuUWouMzTexZrlg1AwycQ0jY2eKXH8sAf13YiXwkf7vbZT848p6i1cryPjrE0oQoTCz",
	"Jjm0ruMYZhtGOpRYFMT34iRJHGbgVQqSjQVmOKecP+MHJaE4iRRtcKKotWLvq6kiFsigNQchShbGUVyU",
	"zJHYPTvNZ9MIUOG39/wzJzhzvDvHv3T7l/3RueM4/2P3bIood+0LPhBLOk0xEbSeQUsyDEosYCVwbS3x",
	"ClqzjZXg9bn1ISEUgojxy78TiZs1A8l9lqc03FRV5eZ6yGDMFNhpnsVsIdhLSlNyeXFRffEigWtyUY7h",
	"IikZ+YyhczbLUczY8UzQ7SwEOeEPJTdcuI7v+MHIdexvUu20M+5dpNiEl9zi55Ap198qVoqNc2r3Wlc4",
	"iuzLHzGMno2SCD7al45mx8gx4XXCVPwmcoWmPgcxgTVClNqxG7jj0Xjgjcat9GEa0bSQeG6dYk+9l6Bq",
	"/oGze5gdvF0ermy+VY9Y3x3ojAU5OSa3k0n/TKoVhTl89gueZnBOpksIIjJdAZRMQYqmb3EcM9adxfAq",
	"TTP8AGI+8jj+dc63nm3j2aunO3wPmTHedEzsYt4fO6ir8hi0NKG+qM6/NWaAsWhHfTJ9IMlXvDv+BHLJ",
	"9oDvodaxClQ4otu86O+k03eSaRK4q1lqMAnTKzplETmcp24nvjIKbd7DDLKNtmfPeHzYHCXct2v37BAk",
	"IYztnp2nkXhF2lbsS5fc8SbPTs8aHdLyE5Iy+CfB9y4DEfwp1x7H/CdfefoYtHU3yzdMrYExW2F4Poc8",
	"8gcyBa1YksVi7HK13WUgIay7l87B14/hEiQL+BH9maMI0Y3p5KDzDbrRa8F+NmVDIztHZBxEtqo3vEUn",
	"KFBpKgfH0tigGERsX5jhLMNrxpyCk7iesFIKQ8o998z6itkHZjdGGVgfz7cFfhgkP3b6MSi3fBusVBB7",
	"9xPOCAoozIR2ewJZZmQgrdfumKikmUnBUGySQSbXkpD9FnO+E88J7ETUKWwmFNyz9j+Sa2SfJeOkMEM4",
	"auIAhXdxjrMVoPYlM9HgGbNjbcPwefzUrq/XJly07fEOTRPNBcmPZDzRYWc8V6W4xnaEgntGnjxRn8IY",
	"oFWH/LUGaXNihXPlJBsD/jG6zp7k+AU/wIwv55sMp5gIMVYlygxHG0PgO+fK6SzG4b3xqcirafwco8T8",
	"vjgqrm7QjZeq+6tcXK1I1LgYRcdzbkmw3zGFP0Q8VbsspVORmiVHhBIKFzATriggvUpNCnYuMgw8dGr5",
	"YSSJJj7mPBIfLABKCJOfYEYoQMnx4uMTjJApBiaKMhmJ0IC/QitYBFE2GfQ4QnzSznVwArs2B0xOvBN7",
	"ak4Gn/spTgWcOxVOakefErqwKDvtoGn+nQY8syxOAlkpoKcBzrSPTiGbhHDvZJtQt7CZEHuAGTnBEi1A",
	"d79AC9AnWJ467BMsztvJpFuAExwiEPOT6a7JLEC/gzHsmu0E5O4ZQ8C9weQ0cDM8RzE8EejHzSkA38IH",
	"ROBpIK9BFp0C8mQJso5R5otZqMKn0aa0Dt5kKFqcDv/uJbUGvPslqQEvJeq3LpTvct966Q756lb402D7",
	"Y46/Tm7EV8ejG/Ev9hTMiHLjDCxG3MLmR2EdmNd1veel8+nnMpVD0SVP7hO8TuyeDbIZohmvjgKyNQT8",
	"vAU8gEe7Z88AEef2XKk+IyuQ0bNwCVDCf6Uh5p/CDBMyE+eMWrGVOchCQCg/dlwkmCDCpyKBwO7ZK0Ao",
	"jri/JYGAvYJTilaIsJYpjjcL/iwjZJnP2NyBB/bkgcQ8gSMGGw53FueQ3G+as6pleZTp7Oefi7T2MgcE",
	"rVIsnN+8rMalvUB0mc/OQ7y6yAjpn8nGF6ki8wLLGb1ItGIve2u3TQ+NCnrVvIvVN0Qo7E4umroXshJR",
	"ZXABlQGRux4ayODI7h1GVU39NKurpgAfu8QqFsBPhPEJ99mT4HsjtyLTwpnmWWxk7dbDARntOM0zZHy+",
	"BElkZPGevVJO1u4P6oX/1rCEU2FWTVtOLdJ8pgI2217JhClyktMjkq9WIDMTmoLFnocmFGQL2K3WMa2y",
	"pOyilWsqGXGFREQJHfqlNNTOM04sDpVN/SNOcyo9ajEKW04QZgibz98eUySYYrdNZcuSQyuwgK1r9R6a",
	"Wa9ly3x2NT2AOD/9dG4NZkjgmh8vrzNe3awIkuTfj9ZjdX/KD2WqRy3gKS25+mQ+KNbJ42bazr3dTenj",
	"xhj2jFGihTN1NHPSYfUTbd63xe7zs2AsHGw/B8IUJJEkr2K93wor7/r27RmvT8Y+uMOB/BR4rvrNHagf",
	"3fEwsHv25+ubM9d3j2fXO3Wav/t5dARDtAIxMUcOoGjHLbld9oOMwGiqdhSzAkA0inY36woo62CzmmFz",
	"33KXK8bIvve2bFLPEuNoGWdyDP+IbcPQb7l9iCzW6Y61Kg5ympSK4ql7OWGcXOdT/yOye5onBT+Y30Sv",
	"r9z2l3FbZQI0XotgigkvqdldHHj94OilO3XrZ1E/Eb4/jeN8+up1evU6/Q29TjiFCaeyjAjteJEq8AzB",
	"Itysu8P0CnhN7JyoBzG9JwKuxUCeqAdlI54GenFYeiL4t5MJZ9LTQC8DCvVIjAMUDAWVKTDTd3pVP6XS",
	"8INUUT2DwHj+3IGmKrv/eP5Oq5NuOtTUitXzBnbvgHNOUBQIO3jUr4fQL+oQujI3d6LUYHNeQk389Gyo",
	"RHXPXpQrQxRuEou8J+ulECETezbVxO+3yqUsJaxtNKNgcX4HFp3RioJFUf16hwqQxwvthoXMyTJjFkbP",
	"Xgm/MOXhQ5JYIk0b5PXaHEdIneo+q2EUF4Hv3Nt1L+gvL1OJMeiyf02WahikKhC8Zz/gY4s+tOw8lXCg",
	"rXTvrne1L+n5PhBGHfYg1Q795EgGTPTsSMQhFANNMY9/Uoct8kREuGqQWLZCRe/ZhHu8u0NT179a1oLw",
	"7RgWRdeTolQdg6gzdfJs+aVGeVtRp0i8YRGa5SHNMyiulbFiRGj1KpFzMROGOkpNsObWe5XG1at81g2f",
	"fat+alfCNMyMRhHlxoA+FoMRb+h3qtTqwO49SHmqcETV30oNZ1MN4zSDhHVugcRCSYQeUJSDWN4cpC5H",
	"AklxN1JznnfJ4TWMSK+QuE856CIDr1aceZ+CymJF6BXp6oS5Kpj0t9uPxJIvqzqHoLztR83nc6cbTet8",
	"se/I78Bit8zmVv7Zsz9ujGxfFWVpcE7COchjal+6Tq/LO7gq91c5TNV9RCsm8zyHi1jxxW24FA5dJzfF",
	"PVtqPCfo5kGWaNEqjBoKi/JLGK+Gb96LSxjfj98F8JpfwnjNL2F81w/AlbqEsVJ0VJ1I2s5jMB76b4ZX",
	"I3A9AIHrO2MYXLsBGMy84XA8dvpXXjAeB1ehrR9WuqPiFo6bGGzeYXEzWHGOWB7DqqM/++bj1X/bxUGe",
	"7TrGf83FV5aD5MYOCUFyjvAFfbzo4HLHogykrr7LcofOI5y/HcyDIBxcvRu8ezMazEJvFFyPnGgU9t+M",
	"RmF/7gXDofe2XNJUz2cIQRwris/zRFTXXwKy5MB9x/NmwQDWyt+rwpJQTLoslmL33cFwPB4PBn3PGQ+d",
	"cjLYXDz1So54c/XGj9y5F8yuroJg6AE/Gnnem5HzdugH7wN3MPY8f+zNVZHKjm7IbBah1ExTVYlyL34t",
	"qlSKK/+M01QpVjkajsaBFxSztwdj1wtZOoYJ7RlP5MjzSkyLDDtIq8GJabvQGW2nwpTq/c5uXpDsukv7",
	"95Cz/IGKgel+WEbwPEF/5tBCEUwomiOYFfcf6fRuRtoJxjVB5I/YHFY2HjmJbH7PzZEY+90m0bhMtVgt",
	"Jpz4ozpOxoEdo/y0Xuj1IYlQyMs6r5d8eVdpUy9YWqA1wziGIDlSsznqdorD9KKqWDDNCH9lN6XFzC8n",
	"0r3KkKMUUAozhu//cx6/gLP51dl752z87bvvPP2bsUSSgpHTJVtN4sjLeNUMJGQqw1F3K4jLq9/zu2G3",
	"4/9Wk2itRgmvpg3i2GJvWoBwXxxVNcq3myXV7dg0s+yJWmrqdd4djMwrTkRaqVfNQMVLJTymQxmhZWDd",
	"YnWDtaXk/bmxZFU7USv1iGv166v3VH75LkTjVJa1cd3Al9ISRlNCefqM5/jucOSMWnZ9reL375OPMiqU",
	"wlrrMVcbaU743IKIGbDiOPNL3ae65oWc7UvplhZf+VFs0e1ZiGWecAV9z+2P/EHQGMFgPA78/qivj6D0",
	"hmsDeJtnMuJHH4JoPva2DEH3/raMJpSw9fFIJM7Es8Z4huNgNBo2huP6waA/GuijKQ8ZtNF8QvzyhPpw",
	"RPPhltFIb7eO/UrB0tGXvZ7Jh0wZ1q78VMxVIl5RHLWzCg1n7dcq1s6e+JZwdIzVz5KBvgn//uV2TMUR",
	"gIZkGYa6O44MiI6gPIN5aiicz1wly4RD5RVLgNRv2NxH3SzLpptUzi03uDJEiscnRSIjBwHaLiO1LapZ",
	"/f2Z1EJEpmWhre8G9actd6MtuKHUD/ZJ26iUWdNQ6qk7PkXbqhvm2zaqHHVJ9zYl4zqJuB9E0N3MTFC+",
	"Y8midPx6kZA3KC6alxu14Lbmfr+kNPWmESJgFsPoMH2lx6FwnzvMyKEwZDhMt+pScf9S454kcS+SctU3",
	"CRPiCLZQnbdkz82K6woSYrxyvmwsX9lTTXkP4Va1bw6ZcSZcqsVd9tuUPS3+vompfGhRbK2XKBR3tPAu",
	"iJUCZNb1yhq2BoD8WaE5QrN+V3hvWsQ4e2ilGQwR4VfaFNAk/PMdI9+rtx1W3bB7+GGbN8LrbldPd7ty",
	"uJ06RLVjmAa5lMNfFzni2idxomXg+BZId6UMU66DBD5Si0A+mRkkeUzJnrxcuzeuHX0kTGt1EVDdrExZ",
	"8+ZY6BbQd21gLPAAUMwE4b5M9EnM6q28U6u5P4ZpPuUKlH7mMY8xoGVPAhvheiL3U5KCEE5RMl3MzDkw",
	"bVvmCq5wtilbPt/fPhGExnvbzESWGk5tQ5ptLEElw9lnXZHbSyWq3iRX7CtbFbRTdCCVr0YtZr6Kp4Ia",
	"O/dZUwPaC9ZKnX1P8EL7U8ANF/HsygHvpE+icfObScWoCVe8KlUZYq3Aht9Hx6/Zyqj1X3d3N16PSxtx",
	"+zm2mBhkfyVM8QpXoXU1U13iVOqa5SlLksexQW+pIsbAWvKpvOyLbbTCiyIvIyLFrexqBM/gsQLpFzFr",
	"34pwpypSUhFqrqffbj+q/a61M3kmIPpikKrQDcbTHu7x6prfgzlarIa/YFEcYGSVvTSuTXhu+Pt3aXB7",
	"HxnEoG6srK3OED/AjKupbs9mkwIoFkdRfRCOnL7Td0IHzkNvHA7m/mjozwe+H81nc991w9Ew9AIeRqru",
	"P7Uv7e9flQdgSnEMM5CE8Kt9+f1rEdv5lStBTu+r8oOIH9j3B/BYfJkBUj4xBH0Wz4qAz6/25YD/otxd",
	"xStF8OdX+7I/5Cepva8yDLR4iQeDFt9UAGjxg/Q5Fd8JeCgfPpBYfH7qlePX6n03KTAaBJ4/DrwqGfqB",
	"3x9qpPC9vuMOAp0erucOB17QSpT+cDDsD4Z+nTKjkT8cBm6NPON+3/e8CjX63nA8GI88jSTeYOy6Xp0s",
	"7nDkuiPXqxBn4LtOf+QMSgoNncB3Sxr57tjTqcQUoqlcoprKk8JsusIJXTZI5w0rNNOoVWGbdq5xgxpt",
	"ajwzcHVyjDU69N0qCbxBlTEGfY0xyiHXOHDgPD1xH1iIs4jLhBgQynagjM4gU9LcwGP/Rs6QvwYTOlU7",
	"jX35xb6oqEgXzmPgBwP3OvBd4I6H18CJrryrAfBm7/rBVfT+zdv+0IfhtTOze/W2xaXa37Se1oDj9eW7",
	"DVMcLhm3+ko8IJyUb9iOXdzeP1VBXrbr8xwVGUiqvT10B8PhMAhc1/H7Y88ZD8djt+9zB27RU3+fnhxv",
	"tK0nZzBk3Og7Xr8/GHpBtSevu56GXt/3RoHv+iO2hEdutSd3j5780baOBoMgGPcDz/eGgTMcBsNqR05n",
	"HfmjYOwNh47DpI3vjceVjoLxHh057d24g37gBOPRyB17ffZvUO1mtBfbtXfUHweuOxiNnYHnDoPRcOhX",
	"uS4I9uhoMNzSz2Dojt2hPxj5Izfwhl6tn+FeE7SlH3/s+n7gjfqO4wy80XBU7WewRz/eFrr5Y88fDUZ9",
	"13c9L3D7zph7/0kMyBJGU3VPlc0jk/KUV/O59PzxmHHIA8yI9AWHeMU9LLaMY1IRK865c+4YvPmlYmLS",
	"gaVVUPrPVUAJd0tIn1yhcbXapK3Hi3VjrtSMjGEH8qkFH1aFw6yGjOk8tFCaWnwtGTMz5DapXTL/LGht",
	"Y9lF2byVr2sT2O4sEW+0oKC5JbSp3wWH3+Xr29Vp/db1o66eLbThrf3dVKao5jRN0eFH+z2eMlwNHtgp",
	"9qLa6qlnc+VyOgM0XE4J+ic8FB8BhykAKKWkM4DFdVKHg9gtE7cNRogTuZCmaohKjToMYIckymAMNtM8",
	"i6e8LG3npx43WowTSDY7JO7WW76reOKeS62st35fuNi0q67bgBuLFbkoCZd2z766+v2a/QEPcIFpuETs",
	"S5kp+EYkBr6BSfTu6le7Z7/l1we+1RIBVYDC9eeJ3bPfa7mA/4UWyxgtltTu2R/+7x/ongH/P2iNeIEe",
	"u2d/ZBtcz/6IIsz/iIzBj+jz9dUt+4DxPbkFGYP+iccSsbeLEILPEGQTlQT3Gecc1q8pTCYczK9lmiGT",
	"NosMpEv5WWZf3eB4swLZPb+u83Yy6bM/ACUzPsbJ1e+f2B+2SkRNuN8SJFuKqJL/gZkxf6yaXlcxCs4L",
	"zjko245tCirNTmy0VZtjn7y7dp4yMswnFb3wzHAL72/3Qy0dy4cMsxE8erqk+1oKcnWN1vNFTlOgQ0tH",
	"+V6ZHxWMf1680VXe50rLgNltdr7VjwGvogiJNy0FrT3HpV0611x8J57owpNommaZ9nvK/nmUqrHv05aW",
	"KIoC6OwloJ3fiWiPThhrD37SiHBbauqmBEL+kOnaTM5szResO5CMQfeAUKt4R4E1q+8Np1MLgsxCKc5A",
	"NIhbbC/5uloqYmgp2skOq3uotmLF3zEitZtVJC9raV7jWLN9jQaqeMcS7xhovcvhalkm0zRK9kwHXDtU",
	"EY4AY/AJeyTO7BkMMwMom3Y7rQvLV6N2A6pumFY9D9vYQyaEbgfYcFoY50K8tBOO26Zj0hb3f2vIWJ0B",
	"AiMLJyriX0b4NYP+pdiQ2WIT8ZbW652sXfR8lyosg/AwFcS4Dyz+g/znvpxfTyw47uDpTs9LMHgV1GM2",
	"LeslrCUy4pCbbyYmrWp0uaiMpHe8SeHhJ29y3zh29L+XbpDm2BeIWtJPwiO22lez8p61QRHPt4iZIrPE",
	"3J6CxYEy6g8Zl7uviSnaHWZgirYt5mXltLb1rPlQmx0dHByJ0jmZMhttDTYHex9k3Ng000KMdsrUr0Um",
	"7Z+IVcek6r7caWWVLZ7KeO6unR4mvtLLTciKQronQas5pEoMwSSKAOZ1b7hhH3JjW68spLIShHNgqTkR",
	"0J9r4US4R2tEpBMhFu/Fwomgyg7xvxkvsYLvSSacCKvCiVDkDqzwCt8DWZyoKKmTSG+C8pIwlZdwuHrx",
	"Is2rkJZehVT3KmSFO4EpuWV5I1J6FfLCqyCSS/55gFdBiooX41Ooi5FKBRVT7ZM2H0LHAzvKg6AF8leM",
	"qtr1QUdnYR6VQClzPfaR9qVipIo57pTjyN7dW9rI+XyqpMBsOUb68M60ae63m91keCHyKhv+BqnD0twQ",
	"xv+MHCygNjbCSr5Ue35vqIK1G13qZdirOUCt0GDExwGfg1dNDjIbCeyNXaA9v1dMCm5sneAyO6fpcvzA",
	"Riakg0pd+i1ZQhDT5bOF4CTaE2UadCI/dpcajBQwzDNENxMGQXDGDIIMZlc55eYjB83tFf5zSeElpSnn",
	"chtJYVOzUCaTvvWZGfdXNx96Igf1zxxmG4vA7AGFkFhphh9QJJV7EXxsqxa2doRou+KQWGxxIEX2pd0/",
	"d877soQhR/uC/SdPilpsJe5qkCtJxiGf29o5+YfIvrR/EVuiCpBn4DzHEUo4L9fLQwzhI71IY4CSgkag",
	"mkx8t0TEQrwyUEkJ0ROMrNnGch6/OGdjkW/Mk43NMqQ2ls+mITz1bF+gaJI3xVDKT9M3ILoVdjZrPNiv",
	"8QfGQgmIRVbNk157l1FPDPVX5RngW1GZzse/fmONilqSpRTaYfoqK3LrLKo6MW859GenFKSpKl988Q+C",
	"6xNbM8daxaYpL+S8UoPH8z1n7A2dkUn0cT+euN8n2uLF42fwFUNZCOo1IJZszTrd5aYlQ7R3g+uuqr2o",
	"HJdIK2cQb14mHxaoKzYwMGJLRBybdlnvu835YvFT4FoWUD3TfpXHFKWx7pgp6p3JGgjVxFSyIRSuzq3/",
	"xrkVgsTKCbQeQIZwTqQI1YJBKLbmKKYw42l/KsWHQ5U5OT0LJWGcRyhZWDFaIUosnLQnMTEwskxDr3TP",
	"kF7Nk9WzitIoPd5mhTPYXIg3mNCKNVYUgyvcgaqEnnne1SsI6t820zeM8r9AM/CyTl+lfp+28ndlsmbF",
	"vxfA5nLT5oq9vl1/+cZjs4pVwGlksbWgCGNplCnXQtVcNi0KpW58lx+enhfXpkKH1jzDq5qTssr7qjau",
	"dadnU1ggjvGaWBuc6wyvuVs3xQrR1gbJw6UFiOB6jZmbvNzOwHUWkzZQWbtX94S0OL/KV7SPU6a6FLd7",
	"tFkL5qZcCkz5sA5qKdb3EQBkluAhTQlKQjilWvWZ/WHkCUXxkTBUGZ9D2kZacaf9W4vawwe021bgfFtD",
	"ZaxPaz6Tby9ONvqOv0/jz5i+x3kS/VixypULGZZ5oDxVM3LxXX06mURVHbxckap8Q1osznFCtY3fX2Xs",
	"q4w9lYwtNvJXoXqwUFUC4FCpSh8vvqNoB0mqstCbR+aFQS2cutsF193jh3dHC6vCDYKiv0bOSAApWMCu",
	"uHfz9+PdwtEwY7yzF9t+l+6Adsat7tzK/0J0F5DJ8wCaLod/fY9Di0+gg3Uq4LxqEX8fLeIY6/zVyvtX",
	"EOpCaO6sjxRn93+JG7ksK/iv5kIuojS6dh83AL+6jvdyHZfhM/UFcEKXccnnL9FdXJDk1VX8qoD8tK5i",
	"LQrtVYE4jZu4XXae1D1cSs8X6RouqHI6t7AeYfkqS19l6atL+Cd1CbdL0B/gCi46f3UDv7qBn3UDt7Pq",
	"X+H+/df0FBjs+Ve376um8Ddx+75abCd3+daFuGQUchEW+abbtY1qMXT9wg6tgTmeXRUTlqmtx81wpTDz",
	"C3JPVqbCSCxzCLcqREAuVDZKN6kgKo2ByDSGo2gui869VHLzePkiF2krkcXMkGmZyddp6kZBdZGhRQqk",
	"jiF/mRn5oidAoLl1HjJCLr4z5WQf86bpB7qdTCwGxTgFt5PJ0apTJtMZj5m128nk77wbsTnSTYobQJca",
	"U7BZ+sYTduQvrXwgYj6Ky6AY3GqCkixAwiAyLWQ3MNUoEiPAZomH3UCXFooRbKX6w/8PAAD//2dLHG8o",
	"7gAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
