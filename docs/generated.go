// Package docs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package docs

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	"github.com/rss3-network/node/schema/worker/decentralized"
	"github.com/rss3-network/node/schema/worker/federated"
	"github.com/rss3-network/protocol-go/schema"
	activityx "github.com/rss3-network/protocol-go/schema/activity"
	"github.com/rss3-network/protocol-go/schema/network"
	tag "github.com/rss3-network/protocol-go/schema/tag"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// PostDecentralizedAccountsJSONBody defines parameters for PostDecentralizedAccounts.
type PostDecentralizedAccountsJSONBody struct {
	// Accounts List of accounts to retrieve activities for
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   int               `json:"limit,omitempty"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag     `json:"tag,omitempty"`
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetDecentralizedNetworkNetworkParams defines parameters for GetDecentralizedNetworkNetwork.
type GetDecentralizedNetworkNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetDecentralizedPlatformPlatformParams defines parameters for GetDecentralizedPlatformPlatform.
type GetDecentralizedPlatformPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetDecentralizedTxIDParams defines parameters for GetDecentralizedTxID.
type GetDecentralizedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetDecentralizedAccountParams defines parameters for GetDecentralizedAccount.
type GetDecentralizedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostFederatedAccountsJSONBody defines parameters for PostFederatedAccounts.
type PostFederatedAccountsJSONBody struct {
	// Accounts List of accounts to retrieve activities for
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   int               `json:"limit,omitempty"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []federated.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag     `json:"tag,omitempty"`
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetFederatedNetworkNetworkParams defines parameters for GetFederatedNetworkNetwork.
type GetFederatedNetworkNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetFederatedPlatformPlatformParams defines parameters for GetFederatedPlatformPlatform.
type GetFederatedPlatformPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetFederatedTxIDParams defines parameters for GetFederatedTxID.
type GetFederatedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetFederatedAccountParams defines parameters for GetFederatedAccount.
type GetFederatedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostDecentralizedAccountsJSONRequestBody defines body for PostDecentralizedAccounts for application/json ContentType.
type PostDecentralizedAccountsJSONRequestBody PostDecentralizedAccountsJSONBody

// PostFederatedAccountsJSONRequestBody defines body for PostFederatedAccounts for application/json ContentType.
type PostFederatedAccountsJSONRequestBody PostFederatedAccountsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Node Operator Info
	// (GET /)
	GetNodeOperatorInfo(ctx echo.Context) error
	// Get Node Activity Count
	// (GET /activity_count)
	GetActivityCount(ctx echo.Context) error
	// Batch Get Accounts Activities
	// (POST /decentralized/accounts)
	PostDecentralizedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /decentralized/network/{network})
	GetDecentralizedNetworkNetwork(ctx echo.Context, network network.Network, params GetDecentralizedNetworkNetworkParams) error
	// Get Platform Activities
	// (GET /decentralized/platform/{platform})
	GetDecentralizedPlatformPlatform(ctx echo.Context, platform decentralized.Platform, params GetDecentralizedPlatformPlatformParams) error
	// Get Activity by ID
	// (GET /decentralized/tx/{id})
	GetDecentralizedTxID(ctx echo.Context, id string, params GetDecentralizedTxIDParams) error
	// Get Account Activities
	// (GET /decentralized/{account})
	GetDecentralizedAccount(ctx echo.Context, account string, params GetDecentralizedAccountParams) error
	// Batch Get Accounts Activities
	// (POST /federated/accounts)
	PostFederatedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /federated/network/{network})
	GetFederatedNetworkNetwork(ctx echo.Context, network network.Network, params GetFederatedNetworkNetworkParams) error
	// Get Platform Activities
	// (GET /federated/platform/{platform})
	GetFederatedPlatformPlatform(ctx echo.Context, platform federated.Platform, params GetFederatedPlatformPlatformParams) error
	// Get Activity by ID
	// (GET /federated/tx/{id})
	GetFederatedTxID(ctx echo.Context, id string, params GetFederatedTxIDParams) error
	// Get Account Activities
	// (GET /federated/{account})
	GetFederatedAccount(ctx echo.Context, account string, params GetFederatedAccountParams) error
	// Get worker config options
	// (GET /networks/config)
	GetNetworksConfig(ctx echo.Context) error
	// Get Node Status
	// (GET /operators/info)
	GetNodeInfo(ctx echo.Context) error
	// Get Node Worker Status
	// (GET /operators/workers_status)
	GetWorkersStatus(ctx echo.Context) error
	// Get RSS Activity by Path
	// (GET /rss/{path})
	GetRSS(ctx echo.Context, path string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetNodeOperatorInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeOperatorInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeOperatorInfo(ctx)
	return err
}

// GetActivityCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetActivityCount(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetActivityCount(ctx)
	return err
}

// PostDecentralizedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedAccounts(ctx)
	return err
}

// GetDecentralizedNetworkNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedNetworkNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedNetworkNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedNetworkNetwork(ctx, network, params)
	return err
}

// GetDecentralizedPlatformPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedPlatformPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform decentralized.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedPlatformPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedPlatformPlatform(ctx, platform, params)
	return err
}

// GetDecentralizedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedTxID(ctx, id, params)
	return err
}

// GetDecentralizedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedAccount(ctx, account, params)
	return err
}

// PostFederatedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostFederatedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFederatedAccounts(ctx)
	return err
}

// GetFederatedNetworkNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedNetworkNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedNetworkNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedNetworkNetwork(ctx, network, params)
	return err
}

// GetFederatedPlatformPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedPlatformPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform federated.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedPlatformPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedPlatformPlatform(ctx, platform, params)
	return err
}

// GetFederatedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedTxID(ctx, id, params)
	return err
}

// GetFederatedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedAccount(ctx, account, params)
	return err
}

// GetNetworksConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworksConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworksConfig(ctx)
	return err
}

// GetNodeInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeInfo(ctx)
	return err
}

// GetWorkersStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkersStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkersStatus(ctx)
	return err
}

// GetRSS converts echo context to params.
func (w *ServerInterfaceWrapper) GetRSS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRSS(ctx, path)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/", wrapper.GetNodeOperatorInfo)
	router.GET(baseURL+"/activity_count", wrapper.GetActivityCount)
	router.POST(baseURL+"/decentralized/accounts", wrapper.PostDecentralizedAccounts)
	router.GET(baseURL+"/decentralized/network/:network", wrapper.GetDecentralizedNetworkNetwork)
	router.GET(baseURL+"/decentralized/platform/:platform", wrapper.GetDecentralizedPlatformPlatform)
	router.GET(baseURL+"/decentralized/tx/:id", wrapper.GetDecentralizedTxID)
	router.GET(baseURL+"/decentralized/:account", wrapper.GetDecentralizedAccount)
	router.POST(baseURL+"/federated/accounts", wrapper.PostFederatedAccounts)
	router.GET(baseURL+"/federated/network/:network", wrapper.GetFederatedNetworkNetwork)
	router.GET(baseURL+"/federated/platform/:platform", wrapper.GetFederatedPlatformPlatform)
	router.GET(baseURL+"/federated/tx/:id", wrapper.GetFederatedTxID)
	router.GET(baseURL+"/federated/:account", wrapper.GetFederatedAccount)
	router.GET(baseURL+"/networks/config", wrapper.GetNetworksConfig)
	router.GET(baseURL+"/operators/info", wrapper.GetNodeInfo)
	router.GET(baseURL+"/operators/workers_status", wrapper.GetWorkersStatus)
	router.GET(baseURL+"/rss/:path", wrapper.GetRSS)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
