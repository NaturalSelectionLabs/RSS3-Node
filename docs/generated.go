// Package docs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package docs

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	"github.com/rss3-network/node/schema/worker/decentralized"
	"github.com/rss3-network/node/schema/worker/federated"
	"github.com/rss3-network/protocol-go/schema"
	activityx "github.com/rss3-network/protocol-go/schema/activity"
	"github.com/rss3-network/protocol-go/schema/network"
	tag "github.com/rss3-network/protocol-go/schema/tag"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// PostDecentralizedAccountsJSONBody defines parameters for PostDecentralizedAccounts.
type PostDecentralizedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   int               `json:"limit,omitempty"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag     `json:"tag,omitempty"`
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetDecentralizedNetworkParams defines parameters for GetDecentralizedNetwork.
type GetDecentralizedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetDecentralizedPlatformParams defines parameters for GetDecentralizedPlatform.
type GetDecentralizedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetDecentralizedTxIDParams defines parameters for GetDecentralizedTxID.
type GetDecentralizedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetDecentralizedAccountParams defines parameters for GetDecentralizedAccount.
type GetDecentralizedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostFederatedAccountsJSONBody defines parameters for PostFederatedAccounts.
type PostFederatedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   int               `json:"limit,omitempty"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []federated.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag     `json:"tag,omitempty"`
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetFederatedNetworkParams defines parameters for GetFederatedNetwork.
type GetFederatedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetFederatedPlatformParams defines parameters for GetFederatedPlatform.
type GetFederatedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetFederatedTxIDParams defines parameters for GetFederatedTxID.
type GetFederatedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetFederatedAccountParams defines parameters for GetFederatedAccount.
type GetFederatedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostDecentralizedAccountsJSONRequestBody defines body for PostDecentralizedAccounts for application/json ContentType.
type PostDecentralizedAccountsJSONRequestBody PostDecentralizedAccountsJSONBody

// PostFederatedAccountsJSONRequestBody defines body for PostFederatedAccounts for application/json ContentType.
type PostFederatedAccountsJSONRequestBody PostFederatedAccountsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Node Operator Info
	// (GET /)
	GetNodeOperatorInfo(ctx echo.Context) error
	// Get Node Activity Count
	// (GET /activity_count)
	GetActivityCount(ctx echo.Context) error
	// Batch Get Accounts Activities
	// (POST /decentralized/accounts)
	PostDecentralizedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /decentralized/network/{network})
	GetDecentralizedNetwork(ctx echo.Context, network network.Network, params GetDecentralizedNetworkParams) error
	// Get Platform Activities
	// (GET /decentralized/platform/{platform})
	GetDecentralizedPlatform(ctx echo.Context, platform decentralized.Platform, params GetDecentralizedPlatformParams) error
	// Get Activity by ID
	// (GET /decentralized/tx/{id})
	GetDecentralizedTxID(ctx echo.Context, id string, params GetDecentralizedTxIDParams) error
	// Get Account Activities
	// (GET /decentralized/{account})
	GetDecentralizedAccount(ctx echo.Context, account string, params GetDecentralizedAccountParams) error
	// Batch Get Accounts Activities
	// (POST /federated/accounts)
	PostFederatedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /federated/network/{network})
	GetFederatedNetwork(ctx echo.Context, network network.Network, params GetFederatedNetworkParams) error
	// Get Platform Activities
	// (GET /federated/platform/{platform})
	GetFederatedPlatform(ctx echo.Context, platform federated.Platform, params GetFederatedPlatformParams) error
	// Get Activity by ID
	// (GET /federated/tx/{id})
	GetFederatedTxID(ctx echo.Context, id string, params GetFederatedTxIDParams) error
	// Get Account Activities
	// (GET /federated/{account})
	GetFederatedAccount(ctx echo.Context, account string, params GetFederatedAccountParams) error
	// Get worker config options
	// (GET /networks/config)
	GetNetworksConfig(ctx echo.Context) error
	// Get Node Status
	// (GET /operators/info)
	GetNodeInfo(ctx echo.Context) error
	// Get Node Worker Status
	// (GET /operators/workers_status)
	GetWorkersStatus(ctx echo.Context) error
	// Get RSS Activity by Path
	// (GET /rss/{path})
	GetRSS(ctx echo.Context, path string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetNodeOperatorInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeOperatorInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeOperatorInfo(ctx)
	return err
}

// GetActivityCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetActivityCount(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetActivityCount(ctx)
	return err
}

// PostDecentralizedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedAccounts(ctx)
	return err
}

// GetDecentralizedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedNetwork(ctx, network, params)
	return err
}

// GetDecentralizedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform decentralized.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedPlatform(ctx, platform, params)
	return err
}

// GetDecentralizedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedTxID(ctx, id, params)
	return err
}

// GetDecentralizedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedAccount(ctx, account, params)
	return err
}

// PostFederatedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostFederatedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFederatedAccounts(ctx)
	return err
}

// GetFederatedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedNetwork(ctx, network, params)
	return err
}

// GetFederatedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform federated.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedPlatform(ctx, platform, params)
	return err
}

// GetFederatedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedTxID(ctx, id, params)
	return err
}

// GetFederatedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedAccount(ctx, account, params)
	return err
}

// GetNetworksConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworksConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworksConfig(ctx)
	return err
}

// GetNodeInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeInfo(ctx)
	return err
}

// GetWorkersStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkersStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkersStatus(ctx)
	return err
}

// GetRSS converts echo context to params.
func (w *ServerInterfaceWrapper) GetRSS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRSS(ctx, path)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/", wrapper.GetNodeOperatorInfo)
	router.GET(baseURL+"/activity_count", wrapper.GetActivityCount)
	router.POST(baseURL+"/decentralized/accounts", wrapper.PostDecentralizedAccounts)
	router.GET(baseURL+"/decentralized/network/:network", wrapper.GetDecentralizedNetwork)
	router.GET(baseURL+"/decentralized/platform/:platform", wrapper.GetDecentralizedPlatform)
	router.GET(baseURL+"/decentralized/tx/:id", wrapper.GetDecentralizedTxID)
	router.GET(baseURL+"/decentralized/:account", wrapper.GetDecentralizedAccount)
	router.POST(baseURL+"/federated/accounts", wrapper.PostFederatedAccounts)
	router.GET(baseURL+"/federated/network/:network", wrapper.GetFederatedNetwork)
	router.GET(baseURL+"/federated/platform/:platform", wrapper.GetFederatedPlatform)
	router.GET(baseURL+"/federated/tx/:id", wrapper.GetFederatedTxID)
	router.GET(baseURL+"/federated/:account", wrapper.GetFederatedAccount)
	router.GET(baseURL+"/networks/config", wrapper.GetNetworksConfig)
	router.GET(baseURL+"/operators/info", wrapper.GetNodeInfo)
	router.GET(baseURL+"/operators/workers_status", wrapper.GetWorkersStatus)
	router.GET(baseURL+"/rss/:path", wrapper.GetRSS)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
