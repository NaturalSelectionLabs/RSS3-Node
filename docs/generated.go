// Package docs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package docs

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/rss3-network/node/schema/worker/decentralized"
	"github.com/rss3-network/node/schema/worker/federated"
	"github.com/rss3-network/protocol-go/schema"
	activityx "github.com/rss3-network/protocol-go/schema/activity"
	"github.com/rss3-network/protocol-go/schema/network"
	"github.com/rss3-network/protocol-go/schema/tag"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// PostDecentralizedAccountsJSONBody defines parameters for PostDecentralizedAccounts.
type PostDecentralizedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   *int              `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag `json:"tag,omitempty"`
	Type []string  `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// PostDecentralizedMetadataJSONBody defines parameters for PostDecentralizedMetadata.
type PostDecentralizedMetadataJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor *string `json:"cursor,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit *int `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`

	// MetadataQueryWhere SQL WHERE clause for metadata filtering (e.g. actions::jsonb @> '[{"metadata": {"from": {"address": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"}, "to": {"address": "0xB3912b20b3aBc78C15e85E13EC0bF334fbB924f7"}}}]')
	MetadataQueryWhere *string                 `json:"metadata_query_where,omitempty" validate:"required"`
	Network            *network.Network        `json:"network,omitempty" validate:"required"`
	Platform           *decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool        `json:"success,omitempty"`
	Tag    *tag.Tag     `json:"tag,omitempty" validate:"required"`
	Type   *schema.Type `json:"type,omitempty" validate:"required"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetDecentralizedNetworkParams defines parameters for GetDecentralizedNetwork.
type GetDecentralizedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// GetDecentralizedPlatformParams defines parameters for GetDecentralizedPlatform.
type GetDecentralizedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`
}

// GetDecentralizedTxIDParams defines parameters for GetDecentralizedTxID.
type GetDecentralizedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// ActionPage Specify the pagination for actions
	ActionPage *int `default:"1" form:"action_page,omitempty" json:"action_page,omitempty" query:"action_page" validate:"min=1"`
}

// GetDecentralizedAccountParams defines parameters for GetDecentralizedAccount.
type GetDecentralizedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// PostFederatedAccountsJSONBody defines parameters for PostFederatedAccounts.
type PostFederatedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   *int              `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []federated.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag `json:"tag,omitempty"`
	Type []string  `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetFederatedNetworkParams defines parameters for GetFederatedNetwork.
type GetFederatedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// GetFederatedPlatformParams defines parameters for GetFederatedPlatform.
type GetFederatedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`
}

// GetFederatedTxIDParams defines parameters for GetFederatedTxID.
type GetFederatedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// ActionPage Specify the pagination for actions
	ActionPage *int `default:"1" form:"action_page,omitempty" json:"action_page,omitempty" query:"action_page" validate:"min=1"`
}

// GetFederatedAccountParams defines parameters for GetFederatedAccount.
type GetFederatedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// PostDecentralizedAccountsJSONRequestBody defines body for PostDecentralizedAccounts for application/json ContentType.
type PostDecentralizedAccountsJSONRequestBody PostDecentralizedAccountsJSONBody

// PostDecentralizedMetadataJSONRequestBody defines body for PostDecentralizedMetadata for application/json ContentType.
type PostDecentralizedMetadataJSONRequestBody PostDecentralizedMetadataJSONBody

// PostFederatedAccountsJSONRequestBody defines body for PostFederatedAccounts for application/json ContentType.
type PostFederatedAccountsJSONRequestBody PostFederatedAccountsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Batch Get Accounts Activities
	// (POST /decentralized/accounts)
	PostDecentralizedAccounts(ctx echo.Context) error
	// Batch Get Activities By Metadata
	// (POST /decentralized/metadata)
	PostDecentralizedMetadata(ctx echo.Context) error
	// Get Network Activities
	// (GET /decentralized/network/{network})
	GetDecentralizedNetwork(ctx echo.Context, network network.Network, params GetDecentralizedNetworkParams) error
	// Get Platform Activities
	// (GET /decentralized/platform/{platform})
	GetDecentralizedPlatform(ctx echo.Context, platform decentralized.Platform, params GetDecentralizedPlatformParams) error
	// Get Activity by ID
	// (GET /decentralized/tx/{id})
	GetDecentralizedTxID(ctx echo.Context, id string, params GetDecentralizedTxIDParams) error
	// Get Account Activities
	// (GET /decentralized/{account})
	GetDecentralizedAccount(ctx echo.Context, account string, params GetDecentralizedAccountParams) error
	// Batch Get Accounts Activities
	// (POST /federated/accounts)
	PostFederatedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /federated/network/{network})
	GetFederatedNetwork(ctx echo.Context, network network.Network, params GetFederatedNetworkParams) error
	// Get Platform Activities
	// (GET /federated/platform/{platform})
	GetFederatedPlatform(ctx echo.Context, platform federated.Platform, params GetFederatedPlatformParams) error
	// Get Activity by ID
	// (GET /federated/tx/{id})
	GetFederatedTxID(ctx echo.Context, id string, params GetFederatedTxIDParams) error
	// Get Account Activities
	// (GET /federated/{account})
	GetFederatedAccount(ctx echo.Context, account string, params GetFederatedAccountParams) error
	// Get worker config options
	// (GET /networks/config)
	GetNetworksConfig(ctx echo.Context) error
	// Get Node Operator Info
	// (GET /operators)
	GetNodeOperatorInfo(ctx echo.Context) error
	// Get Node Activity Count
	// (GET /operators/activity_count)
	GetActivityCount(ctx echo.Context) error
	// Get Node Status
	// (GET /operators/info)
	GetNodeInfo(ctx echo.Context) error
	// Get Node Worker Status
	// (GET /operators/workers_status)
	GetWorkersStatus(ctx echo.Context) error
	// Get RSS Activity by Path
	// (GET /rss/{path})
	GetRSS(ctx echo.Context, path string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostDecentralizedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedAccounts(ctx)
	return err
}

// PostDecentralizedMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedMetadata(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedMetadata(ctx)
	return err
}

// GetDecentralizedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	//err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "network", &network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedNetworkParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedNetwork(ctx, network, params)
	return err
}

// GetDecentralizedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform decentralized.Platform

	//err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "platform", &platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedPlatformParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedPlatform(ctx, platform, params)
	return err
}

// GetDecentralizedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	//err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "id", &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedTxIDParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedTxID(ctx, id, params)
	return err
}

// GetDecentralizedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	//err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "account", &account)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedAccountParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedAccount(ctx, account, params)
	return err
}

// PostFederatedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostFederatedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFederatedAccounts(ctx)
	return err
}

// GetFederatedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	//err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "network", &network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedNetworkParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedNetwork(ctx, network, params)
	return err
}

// GetFederatedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform federated.Platform

	//err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "platform", &platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedPlatformParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedPlatform(ctx, platform, params)
	return err
}

// GetFederatedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	//err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "id", &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedTxIDParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedTxID(ctx, id, params)
	return err
}

// GetFederatedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	//err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "account", &account)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedAccountParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedAccount(ctx, account, params)
	return err
}

// GetNetworksConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworksConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworksConfig(ctx)
	return err
}

// GetNodeOperatorInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeOperatorInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeOperatorInfo(ctx)
	return err
}

// GetActivityCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetActivityCount(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetActivityCount(ctx)
	return err
}

// GetNodeInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeInfo(ctx)
	return err
}

// GetWorkersStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkersStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkersStatus(ctx)
	return err
}

// GetRSS converts echo context to params.
func (w *ServerInterfaceWrapper) GetRSS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	//err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "path", &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRSS(ctx, path)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/decentralized/accounts", wrapper.PostDecentralizedAccounts)
	router.POST(baseURL+"/decentralized/metadata", wrapper.PostDecentralizedMetadata)
	router.GET(baseURL+"/decentralized/network/:network", wrapper.GetDecentralizedNetwork)
	router.GET(baseURL+"/decentralized/platform/:platform", wrapper.GetDecentralizedPlatform)
	router.GET(baseURL+"/decentralized/tx/:id", wrapper.GetDecentralizedTxID)
	router.GET(baseURL+"/decentralized/:account", wrapper.GetDecentralizedAccount)
	router.POST(baseURL+"/federated/accounts", wrapper.PostFederatedAccounts)
	router.GET(baseURL+"/federated/network/:network", wrapper.GetFederatedNetwork)
	router.GET(baseURL+"/federated/platform/:platform", wrapper.GetFederatedPlatform)
	router.GET(baseURL+"/federated/tx/:id", wrapper.GetFederatedTxID)
	router.GET(baseURL+"/federated/:account", wrapper.GetFederatedAccount)
	router.GET(baseURL+"/networks/config", wrapper.GetNetworksConfig)
	router.GET(baseURL+"/operators", wrapper.GetNodeOperatorInfo)
	router.GET(baseURL+"/operators/activity_count", wrapper.GetActivityCount)
	router.GET(baseURL+"/operators/info", wrapper.GetNodeInfo)
	router.GET(baseURL+"/operators/workers_status", wrapper.GetWorkersStatus)
	router.GET(baseURL+"/rss/:path", wrapper.GetRSS)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
