// Package docs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package docs

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	"github.com/rss3-network/node/schema/worker/decentralized"
	"github.com/rss3-network/node/schema/worker/federated"
	"github.com/rss3-network/protocol-go/schema"
	activityx "github.com/rss3-network/protocol-go/schema/activity"
	"github.com/rss3-network/protocol-go/schema/network"
	tag "github.com/rss3-network/protocol-go/schema/tag"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// PostDecentralizedAccountsJSONBody defines parameters for PostDecentralizedAccounts.
type PostDecentralizedAccountsJSONBody struct {
	// Accounts List of accounts to retrieve activities for
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor *string `json:"cursor,omitempty"`

	// Direction The direction of an activity.
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit int `json:"limit,omitempty"`

	// Network Retrieve activities from the specified network(s)
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag []tag.Tag `json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s)
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetDecentralizedNetworkNetworkParams defines parameters for GetDecentralizedNetworkNetwork.
type GetDecentralizedNetworkNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetDecentralizedPlatformPlatformParams defines parameters for GetDecentralizedPlatformPlatform.
type GetDecentralizedPlatformPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetDecentralizedTxIdParams defines parameters for GetDecentralizedTxId.
type GetDecentralizedTxIdParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetDecentralizedAccountParams defines parameters for GetDecentralizedAccount.
type GetDecentralizedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostFederatedAccountsJSONBody defines parameters for PostFederatedAccounts.
type PostFederatedAccountsJSONBody struct {
	// Accounts List of accounts to retrieve activities for
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor *string `json:"cursor,omitempty"`

	// Direction The direction of an activity.
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit int `json:"limit,omitempty"`

	// Network Retrieve activities from the specified network(s)
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []federated.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag []tag.Tag `json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s)
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetFederatedNetworkNetworkParams defines parameters for GetFederatedNetworkNetwork.
type GetFederatedNetworkNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetFederatedPlatformPlatformParams defines parameters for GetFederatedPlatformPlatform.
type GetFederatedPlatformPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetFederatedTxIdParams defines parameters for GetFederatedTxId.
type GetFederatedTxIdParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetFederatedAccountParams defines parameters for GetFederatedAccount.
type GetFederatedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostDecentralizedAccountsJSONRequestBody defines body for PostDecentralizedAccounts for application/json ContentType.
type PostDecentralizedAccountsJSONRequestBody PostDecentralizedAccountsJSONBody

// PostFederatedAccountsJSONRequestBody defines body for PostFederatedAccounts for application/json ContentType.
type PostFederatedAccountsJSONRequestBody PostFederatedAccountsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Node Operator Info
	// (GET /)
	Get(ctx echo.Context) error
	// Get Node Activity Count
	// (GET /activity_count)
	GetActivityCount(ctx echo.Context) error
	// Batch Get Accounts Activities
	// (POST /decentralized/accounts)
	PostDecentralizedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /decentralized/network/{network})
	GetDecentralizedNetworkNetwork(ctx echo.Context, network network.Network, params GetDecentralizedNetworkNetworkParams) error
	// Get Platform Activities
	// (GET /decentralized/platform/{platform})
	GetDecentralizedPlatformPlatform(ctx echo.Context, platform decentralized.Platform, params GetDecentralizedPlatformPlatformParams) error
	// Get Activity by ID
	// (GET /decentralized/tx/{id})
	GetDecentralizedTxId(ctx echo.Context, id string, params GetDecentralizedTxIdParams) error
	// Get Account Activities
	// (GET /decentralized/{account})
	GetDecentralizedAccount(ctx echo.Context, account string, params GetDecentralizedAccountParams) error
	// Batch Get Accounts Activities
	// (POST /federated/accounts)
	PostFederatedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /federated/network/{network})
	GetFederatedNetworkNetwork(ctx echo.Context, network network.Network, params GetFederatedNetworkNetworkParams) error
	// Get Platform Activities
	// (GET /federated/platform/{platform})
	GetFederatedPlatformPlatform(ctx echo.Context, platform federated.Platform, params GetFederatedPlatformPlatformParams) error
	// Get Activity by ID
	// (GET /federated/tx/{id})
	GetFederatedTxId(ctx echo.Context, id string, params GetFederatedTxIdParams) error
	// Get Account Activities
	// (GET /federated/{account})
	GetFederatedAccount(ctx echo.Context, account string, params GetFederatedAccountParams) error
	// Get Node Status
	// (GET /info)
	GetInfo(ctx echo.Context) error
	// Get worker config options
	// (GET /networks/config)
	GetNetworksConfig(ctx echo.Context) error
	// Get Node Version
	// (GET /version)
	GetVersion(ctx echo.Context) error
	// Get Node Worker Status
	// (GET /workers_status)
	GetWorkersStatus(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Get converts echo context to params.
func (w *ServerInterfaceWrapper) Get(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Get(ctx)
	return err
}

// GetActivityCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetActivityCount(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetActivityCount(ctx)
	return err
}

// PostDecentralizedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedAccounts(ctx)
	return err
}

// GetDecentralizedNetworkNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedNetworkNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedNetworkNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedNetworkNetwork(ctx, network, params)
	return err
}

// GetDecentralizedPlatformPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedPlatformPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform decentralized.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedPlatformPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedPlatformPlatform(ctx, platform, params)
	return err
}

// GetDecentralizedTxId converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedTxId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedTxIdParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedTxId(ctx, id, params)
	return err
}

// GetDecentralizedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedAccount(ctx, account, params)
	return err
}

// PostFederatedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostFederatedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFederatedAccounts(ctx)
	return err
}

// GetFederatedNetworkNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedNetworkNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedNetworkNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedNetworkNetwork(ctx, network, params)
	return err
}

// GetFederatedPlatformPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedPlatformPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform federated.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedPlatformPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedPlatformPlatform(ctx, platform, params)
	return err
}

// GetFederatedTxId converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedTxId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedTxIdParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedTxId(ctx, id, params)
	return err
}

// GetFederatedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedAccount(ctx, account, params)
	return err
}

// GetInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetInfo(ctx)
	return err
}

// GetNetworksConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworksConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworksConfig(ctx)
	return err
}

// GetVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetVersion(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetVersion(ctx)
	return err
}

// GetWorkersStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkersStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkersStatus(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/", wrapper.Get)
	router.GET(baseURL+"/activity_count", wrapper.GetActivityCount)
	router.POST(baseURL+"/decentralized/accounts", wrapper.PostDecentralizedAccounts)
	router.GET(baseURL+"/decentralized/network/:network", wrapper.GetDecentralizedNetworkNetwork)
	router.GET(baseURL+"/decentralized/platform/:platform", wrapper.GetDecentralizedPlatformPlatform)
	router.GET(baseURL+"/decentralized/tx/:id", wrapper.GetDecentralizedTxId)
	router.GET(baseURL+"/decentralized/:account", wrapper.GetDecentralizedAccount)
	router.POST(baseURL+"/federated/accounts", wrapper.PostFederatedAccounts)
	router.GET(baseURL+"/federated/network/:network", wrapper.GetFederatedNetworkNetwork)
	router.GET(baseURL+"/federated/platform/:platform", wrapper.GetFederatedPlatformPlatform)
	router.GET(baseURL+"/federated/tx/:id", wrapper.GetFederatedTxId)
	router.GET(baseURL+"/federated/:account", wrapper.GetFederatedAccount)
	router.GET(baseURL+"/info", wrapper.GetInfo)
	router.GET(baseURL+"/networks/config", wrapper.GetNetworksConfig)
	router.GET(baseURL+"/version", wrapper.GetVersion)
	router.GET(baseURL+"/workers_status", wrapper.GetWorkersStatus)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
