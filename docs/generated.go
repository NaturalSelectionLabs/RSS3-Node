// Package docs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package docs

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	"github.com/rss3-network/node/schema/worker/decentralized"
	"github.com/rss3-network/node/schema/worker/federated"
	"github.com/rss3-network/protocol-go/schema"
	activityx "github.com/rss3-network/protocol-go/schema/activity"
	"github.com/rss3-network/protocol-go/schema/network"
	tag "github.com/rss3-network/protocol-go/schema/tag"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// PostDecentralizedAccountsJSONBody defines parameters for PostDecentralizedAccounts.
type PostDecentralizedAccountsJSONBody struct {
	// Accounts List of accounts to retrieve activities for
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   int               `json:"limit,omitempty"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag     `json:"tag,omitempty"`
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetDecentralizedNetworkParams defines parameters for GetDecentralizedNetwork.
type GetDecentralizedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetDecentralizedPlatformParams defines parameters for GetDecentralizedPlatform.
type GetDecentralizedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetDecentralizedTxIDParams defines parameters for GetDecentralizedTxID.
type GetDecentralizedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetDecentralizedAccountParams defines parameters for GetDecentralizedAccount.
type GetDecentralizedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostFederatedAccountsJSONBody defines parameters for PostFederatedAccounts.
type PostFederatedAccountsJSONBody struct {
	// Accounts List of accounts to retrieve activities for
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   int               `json:"limit,omitempty"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []federated.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag     `json:"tag,omitempty"`
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetFederatedNetworkParams defines parameters for GetFederatedNetwork.
type GetFederatedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetFederatedPlatformParams defines parameters for GetFederatedPlatform.
type GetFederatedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetFederatedTxIDParams defines parameters for GetFederatedTxID.
type GetFederatedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetFederatedAccountParams defines parameters for GetFederatedAccount.
type GetFederatedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostDecentralizedAccountsJSONRequestBody defines body for PostDecentralizedAccounts for application/json ContentType.
type PostDecentralizedAccountsJSONRequestBody PostDecentralizedAccountsJSONBody

// PostFederatedAccountsJSONRequestBody defines body for PostFederatedAccounts for application/json ContentType.
type PostFederatedAccountsJSONRequestBody PostFederatedAccountsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Node Operator Info
	// (GET /)
	GetNodeOperatorInfo(ctx echo.Context) error
	// Get Node Activity Count
	// (GET /activity_count)
	GetActivityCount(ctx echo.Context) error
	// Batch Get Accounts Activities
	// (POST /decentralized/accounts)
	PostDecentralizedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /decentralized/network/{network})
	GetDecentralizedNetwork(ctx echo.Context, network network.Network, params GetDecentralizedNetworkParams) error
	// Get Platform Activities
	// (GET /decentralized/platform/{platform})
	GetDecentralizedPlatform(ctx echo.Context, platform decentralized.Platform, params GetDecentralizedPlatformParams) error
	// Get Activity by ID
	// (GET /decentralized/tx/{id})
	GetDecentralizedTxID(ctx echo.Context, id string, params GetDecentralizedTxIDParams) error
	// Get Account Activities
	// (GET /decentralized/{account})
	GetDecentralizedAccount(ctx echo.Context, account string, params GetDecentralizedAccountParams) error
	// Batch Get Accounts Activities
	// (POST /federated/accounts)
	PostFederatedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /federated/network/{network})
	GetFederatedNetwork(ctx echo.Context, network network.Network, params GetFederatedNetworkParams) error
	// Get Platform Activities
	// (GET /federated/platform/{platform})
	GetFederatedPlatform(ctx echo.Context, platform federated.Platform, params GetFederatedPlatformParams) error
	// Get Activity by ID
	// (GET /federated/tx/{id})
	GetFederatedTxID(ctx echo.Context, id string, params GetFederatedTxIDParams) error
	// Get Account Activities
	// (GET /federated/{account})
	GetFederatedAccount(ctx echo.Context, account string, params GetFederatedAccountParams) error
	// Get worker config options
	// (GET /networks/config)
	GetNetworksConfig(ctx echo.Context) error
	// Get Node Status
	// (GET /operators/info)
	GetNodeInfo(ctx echo.Context) error
	// Get Node Worker Status
	// (GET /operators/workers_status)
	GetWorkersStatus(ctx echo.Context) error
	// Get RSS Activity by Path
	// (GET /rss/{path})
	GetRSS(ctx echo.Context, path string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetNodeOperatorInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeOperatorInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeOperatorInfo(ctx)
	return err
}

// GetActivityCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetActivityCount(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetActivityCount(ctx)
	return err
}

// PostDecentralizedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedAccounts(ctx)
	return err
}

// GetDecentralizedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedNetwork(ctx, network, params)
	return err
}

// GetDecentralizedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform decentralized.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedPlatform(ctx, platform, params)
	return err
}

// GetDecentralizedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedTxID(ctx, id, params)
	return err
}

// GetDecentralizedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedAccount(ctx, account, params)
	return err
}

// PostFederatedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostFederatedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFederatedAccounts(ctx)
	return err
}

// GetFederatedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedNetwork(ctx, network, params)
	return err
}

// GetFederatedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform federated.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedPlatform(ctx, platform, params)
	return err
}

// GetFederatedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedTxID(ctx, id, params)
	return err
}

// GetFederatedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedAccount(ctx, account, params)
	return err
}

// GetNetworksConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworksConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworksConfig(ctx)
	return err
}

// GetNodeInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeInfo(ctx)
	return err
}

// GetWorkersStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkersStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkersStatus(ctx)
	return err
}

// GetRSS converts echo context to params.
func (w *ServerInterfaceWrapper) GetRSS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRSS(ctx, path)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/", wrapper.GetNodeOperatorInfo)
	router.GET(baseURL+"/activity_count", wrapper.GetActivityCount)
	router.POST(baseURL+"/decentralized/accounts", wrapper.PostDecentralizedAccounts)
	router.GET(baseURL+"/decentralized/network/:network", wrapper.GetDecentralizedNetwork)
	router.GET(baseURL+"/decentralized/platform/:platform", wrapper.GetDecentralizedPlatform)
	router.GET(baseURL+"/decentralized/tx/:id", wrapper.GetDecentralizedTxID)
	router.GET(baseURL+"/decentralized/:account", wrapper.GetDecentralizedAccount)
	router.POST(baseURL+"/federated/accounts", wrapper.PostFederatedAccounts)
	router.GET(baseURL+"/federated/network/:network", wrapper.GetFederatedNetwork)
	router.GET(baseURL+"/federated/platform/:platform", wrapper.GetFederatedPlatform)
	router.GET(baseURL+"/federated/tx/:id", wrapper.GetFederatedTxID)
	router.GET(baseURL+"/federated/:account", wrapper.GetFederatedAccount)
	router.GET(baseURL+"/networks/config", wrapper.GetNetworksConfig)
	router.GET(baseURL+"/operators/info", wrapper.GetNodeInfo)
	router.GET(baseURL+"/operators/workers_status", wrapper.GetWorkersStatus)
	router.GET(baseURL+"/rss/:path", wrapper.GetRSS)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
