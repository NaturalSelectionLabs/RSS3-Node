// Package docs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package docs

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	"github.com/rss3-network/node/schema/worker/decentralized"
	"github.com/rss3-network/node/schema/worker/federated"
	"github.com/rss3-network/protocol-go/schema"
	activityx "github.com/rss3-network/protocol-go/schema/activity"
	"github.com/rss3-network/protocol-go/schema/network"
	tag "github.com/rss3-network/protocol-go/schema/tag"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// PostDecentralizedAccountsJSONBody defines parameters for PostDecentralizedAccounts.
type PostDecentralizedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   int               `json:"limit,omitempty"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag     `json:"tag,omitempty"`
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetDecentralizedNetworkParams defines parameters for GetDecentralizedNetwork.
type GetDecentralizedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetDecentralizedPlatformParams defines parameters for GetDecentralizedPlatform.
type GetDecentralizedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetDecentralizedTxIDParams defines parameters for GetDecentralizedTxID.
type GetDecentralizedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetDecentralizedAccountParams defines parameters for GetDecentralizedAccount.
type GetDecentralizedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostFederatedAccountsJSONBody defines parameters for PostFederatedAccounts.
type PostFederatedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   int               `json:"limit,omitempty"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []federated.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag     `json:"tag,omitempty"`
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetFederatedNetworkParams defines parameters for GetFederatedNetwork.
type GetFederatedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetFederatedPlatformParams defines parameters for GetFederatedPlatform.
type GetFederatedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetFederatedTxIDParams defines parameters for GetFederatedTxID.
type GetFederatedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetFederatedAccountParams defines parameters for GetFederatedAccount.
type GetFederatedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostDecentralizedAccountsJSONRequestBody defines body for PostDecentralizedAccounts for application/json ContentType.
type PostDecentralizedAccountsJSONRequestBody PostDecentralizedAccountsJSONBody

// PostFederatedAccountsJSONRequestBody defines body for PostFederatedAccounts for application/json ContentType.
type PostFederatedAccountsJSONRequestBody PostFederatedAccountsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Node Operator Info
	// (GET /)
	GetNodeOperatorInfo(ctx echo.Context) error
	// Get Node Activity Count
	// (GET /activity_count)
	GetActivityCount(ctx echo.Context) error
	// Batch Get Accounts Activities
	// (POST /decentralized/accounts)
	PostDecentralizedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /decentralized/network/{network})
	GetDecentralizedNetwork(ctx echo.Context, network network.Network, params GetDecentralizedNetworkParams) error
	// Get Platform Activities
	// (GET /decentralized/platform/{platform})
	GetDecentralizedPlatform(ctx echo.Context, platform decentralized.Platform, params GetDecentralizedPlatformParams) error
	// Get Activity by ID
	// (GET /decentralized/tx/{id})
	GetDecentralizedTxID(ctx echo.Context, id string, params GetDecentralizedTxIDParams) error
	// Get Account Activities
	// (GET /decentralized/{account})
	GetDecentralizedAccount(ctx echo.Context, account string, params GetDecentralizedAccountParams) error
	// Batch Get Accounts Activities
	// (POST /federated/accounts)
	PostFederatedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /federated/network/{network})
	GetFederatedNetwork(ctx echo.Context, network network.Network, params GetFederatedNetworkParams) error
	// Get Platform Activities
	// (GET /federated/platform/{platform})
	GetFederatedPlatform(ctx echo.Context, platform federated.Platform, params GetFederatedPlatformParams) error
	// Get Activity by ID
	// (GET /federated/tx/{id})
	GetFederatedTxID(ctx echo.Context, id string, params GetFederatedTxIDParams) error
	// Get Account Activities
	// (GET /federated/{account})
	GetFederatedAccount(ctx echo.Context, account string, params GetFederatedAccountParams) error
	// Get worker config options
	// (GET /networks/config)
	GetNetworksConfig(ctx echo.Context) error
	// Get Node Status
	// (GET /operators/info)
	GetNodeInfo(ctx echo.Context) error
	// Get Node Worker Status
	// (GET /operators/workers_status)
	GetWorkersStatus(ctx echo.Context) error
	// Get RSS Activity by Path
	// (GET /rss/{path})
	GetRSS(ctx echo.Context, path string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetNodeOperatorInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeOperatorInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeOperatorInfo(ctx)
	return err
}

// GetActivityCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetActivityCount(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetActivityCount(ctx)
	return err
}

// PostDecentralizedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedAccounts(ctx)
	return err
}

// GetDecentralizedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedNetwork(ctx, network, params)
	return err
}

// GetDecentralizedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform decentralized.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedPlatform(ctx, platform, params)
	return err
}

// GetDecentralizedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedTxID(ctx, id, params)
	return err
}

// GetDecentralizedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedAccount(ctx, account, params)
	return err
}

// PostFederatedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostFederatedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFederatedAccounts(ctx)
	return err
}

// GetFederatedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedNetwork(ctx, network, params)
	return err
}

// GetFederatedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform federated.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedPlatform(ctx, platform, params)
	return err
}

// GetFederatedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedTxID(ctx, id, params)
	return err
}

// GetFederatedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedAccount(ctx, account, params)
	return err
}

// GetNetworksConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworksConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworksConfig(ctx)
	return err
}

// GetNodeInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeInfo(ctx)
	return err
}

// GetWorkersStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkersStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkersStatus(ctx)
	return err
}

// GetRSS converts echo context to params.
func (w *ServerInterfaceWrapper) GetRSS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRSS(ctx, path)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/", wrapper.GetNodeOperatorInfo)
	router.GET(baseURL+"/activity_count", wrapper.GetActivityCount)
	router.POST(baseURL+"/decentralized/accounts", wrapper.PostDecentralizedAccounts)
	router.GET(baseURL+"/decentralized/network/:network", wrapper.GetDecentralizedNetwork)
	router.GET(baseURL+"/decentralized/platform/:platform", wrapper.GetDecentralizedPlatform)
	router.GET(baseURL+"/decentralized/tx/:id", wrapper.GetDecentralizedTxID)
	router.GET(baseURL+"/decentralized/:account", wrapper.GetDecentralizedAccount)
	router.POST(baseURL+"/federated/accounts", wrapper.PostFederatedAccounts)
	router.GET(baseURL+"/federated/network/:network", wrapper.GetFederatedNetwork)
	router.GET(baseURL+"/federated/platform/:platform", wrapper.GetFederatedPlatform)
	router.GET(baseURL+"/federated/tx/:id", wrapper.GetFederatedTxID)
	router.GET(baseURL+"/federated/:account", wrapper.GetFederatedAccount)
	router.GET(baseURL+"/networks/config", wrapper.GetNetworksConfig)
	router.GET(baseURL+"/operators/info", wrapper.GetNodeInfo)
	router.GET(baseURL+"/operators/workers_status", wrapper.GetWorkersStatus)
	router.GET(baseURL+"/rss/:path", wrapper.GetRSS)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
