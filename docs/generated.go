// Package docs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package docs

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/rss3-network/node/schema/worker/decentralized"
	"github.com/rss3-network/node/schema/worker/federated"
	"github.com/rss3-network/protocol-go/schema"
	activityx "github.com/rss3-network/protocol-go/schema/activity"
	"github.com/rss3-network/protocol-go/schema/metadata"
	"github.com/rss3-network/protocol-go/schema/network"
	"github.com/rss3-network/protocol-go/schema/tag"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// PostDecentralizedAccountsJSONBody defines parameters for PostDecentralizedAccounts.
type PostDecentralizedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   *int              `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag `json:"tag,omitempty"`
	Type []string  `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// PostDecentralizedMetadataJSONBody defines parameters for PostDecentralizedMetadata.
type PostDecentralizedMetadataJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit    *int                   `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`
	Metadata metadata.Metadata      `json:"metadata,omitempty"`
	Network  *network.Network       `json:"network,omitempty"`
	Platform decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool       `json:"success,omitempty"`
	Tag    tag.Tag     `json:"tag,omitempty"`
	Type   schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetDecentralizedNetworkParams defines parameters for GetDecentralizedNetwork.
type GetDecentralizedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// GetDecentralizedPlatformParams defines parameters for GetDecentralizedPlatform.
type GetDecentralizedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`
}

// GetDecentralizedTxIDParams defines parameters for GetDecentralizedTxID.
type GetDecentralizedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// ActionPage Specify the pagination for actions
	ActionPage *int `default:"1" form:"action_page,omitempty" json:"action_page,omitempty" query:"action_page" validate:"min=1"`
}

// GetDecentralizedAccountParams defines parameters for GetDecentralizedAccount.
type GetDecentralizedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// PostFederatedAccountsJSONBody defines parameters for PostFederatedAccounts.
type PostFederatedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   *int              `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []federated.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag `json:"tag,omitempty"`
	Type []string  `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetFederatedNetworkParams defines parameters for GetFederatedNetwork.
type GetFederatedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// GetFederatedPlatformParams defines parameters for GetFederatedPlatform.
type GetFederatedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`
}

// GetFederatedTxIDParams defines parameters for GetFederatedTxID.
type GetFederatedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// ActionPage Specify the pagination for actions
	ActionPage *int `default:"1" form:"action_page,omitempty" json:"action_page,omitempty" query:"action_page" validate:"min=1"`
}

// GetFederatedAccountParams defines parameters for GetFederatedAccount.
type GetFederatedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// PostDecentralizedAccountsJSONRequestBody defines body for PostDecentralizedAccounts for application/json ContentType.
type PostDecentralizedAccountsJSONRequestBody PostDecentralizedAccountsJSONBody

// PostDecentralizedMetadataJSONRequestBody defines body for PostDecentralizedMetadata for application/json ContentType.
type PostDecentralizedMetadataJSONRequestBody PostDecentralizedMetadataJSONBody

// PostFederatedAccountsJSONRequestBody defines body for PostFederatedAccounts for application/json ContentType.
type PostFederatedAccountsJSONRequestBody PostFederatedAccountsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Batch Get Accounts Activities
	// (POST /decentralized/accounts)
	PostDecentralizedAccounts(ctx echo.Context) error
	// Batch Get Activities By Metadata
	// (POST /decentralized/metadata)
	PostDecentralizedMetadata(ctx echo.Context) error
	// Get Network Activities
	// (GET /decentralized/network/{network})
	GetDecentralizedNetwork(ctx echo.Context, network network.Network, params GetDecentralizedNetworkParams) error
	// Get Platform Activities
	// (GET /decentralized/platform/{platform})
	GetDecentralizedPlatform(ctx echo.Context, platform decentralized.Platform, params GetDecentralizedPlatformParams) error
	// Get Activity by ID
	// (GET /decentralized/tx/{id})
	GetDecentralizedTxID(ctx echo.Context, id string, params GetDecentralizedTxIDParams) error
	// Get Account Activities
	// (GET /decentralized/{account})
	GetDecentralizedAccount(ctx echo.Context, account string, params GetDecentralizedAccountParams) error
	// Batch Get Accounts Activities
	// (POST /federated/accounts)
	PostFederatedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /federated/network/{network})
	GetFederatedNetwork(ctx echo.Context, network network.Network, params GetFederatedNetworkParams) error
	// Get Platform Activities
	// (GET /federated/platform/{platform})
	GetFederatedPlatform(ctx echo.Context, platform federated.Platform, params GetFederatedPlatformParams) error
	// Get Activity by ID
	// (GET /federated/tx/{id})
	GetFederatedTxID(ctx echo.Context, id string, params GetFederatedTxIDParams) error
	// Get Account Activities
	// (GET /federated/{account})
	GetFederatedAccount(ctx echo.Context, account string, params GetFederatedAccountParams) error
	// Get worker config options
	// (GET /networks/config)
	GetNetworksConfig(ctx echo.Context) error
	// Get Node Operator Info
	// (GET /operators)
	GetNodeOperatorInfo(ctx echo.Context) error
	// Get Node Activity Count
	// (GET /operators/activity_count)
	GetActivityCount(ctx echo.Context) error
	// Get Node Status
	// (GET /operators/info)
	GetNodeInfo(ctx echo.Context) error
	// Get Node Worker Status
	// (GET /operators/workers_status)
	GetWorkersStatus(ctx echo.Context) error
	// Get RSS Activity by Path
	// (GET /rss/{path})
	GetRSS(ctx echo.Context, path string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostDecentralizedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedAccounts(ctx)
	return err
}

// PostDecentralizedMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedMetadata(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedMetadata(ctx)
	return err
}

// GetDecentralizedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	//err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "network", &network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedNetworkParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedNetwork(ctx, network, params)
	return err
}

// GetDecentralizedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform decentralized.Platform

	//err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "platform", &platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedPlatformParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedPlatform(ctx, platform, params)
	return err
}

// GetDecentralizedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	//err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "id", &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedTxIDParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedTxID(ctx, id, params)
	return err
}

// GetDecentralizedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	//err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "account", &account)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedAccountParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedAccount(ctx, account, params)
	return err
}

// PostFederatedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostFederatedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFederatedAccounts(ctx)
	return err
}

// GetFederatedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	//err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "network", &network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedNetworkParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedNetwork(ctx, network, params)
	return err
}

// GetFederatedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform federated.Platform

	//err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "platform", &platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedPlatformParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedPlatform(ctx, platform, params)
	return err
}

// GetFederatedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	//err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "id", &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedTxIDParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedTxID(ctx, id, params)
	return err
}

// GetFederatedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	//err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "account", &account)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedAccountParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedAccount(ctx, account, params)
	return err
}

// GetNetworksConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworksConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworksConfig(ctx)
	return err
}

// GetNodeOperatorInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeOperatorInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeOperatorInfo(ctx)
	return err
}

// GetActivityCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetActivityCount(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetActivityCount(ctx)
	return err
}

// GetNodeInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeInfo(ctx)
	return err
}

// GetWorkersStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkersStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkersStatus(ctx)
	return err
}

// GetRSS converts echo context to params.
func (w *ServerInterfaceWrapper) GetRSS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	//err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "path", &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRSS(ctx, path)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/decentralized/accounts", wrapper.PostDecentralizedAccounts)
	router.POST(baseURL+"/decentralized/metadata", wrapper.PostDecentralizedMetadata)
	router.GET(baseURL+"/decentralized/network/:network", wrapper.GetDecentralizedNetwork)
	router.GET(baseURL+"/decentralized/platform/:platform", wrapper.GetDecentralizedPlatform)
	router.GET(baseURL+"/decentralized/tx/:id", wrapper.GetDecentralizedTxID)
	router.GET(baseURL+"/decentralized/:account", wrapper.GetDecentralizedAccount)
	router.POST(baseURL+"/federated/accounts", wrapper.PostFederatedAccounts)
	router.GET(baseURL+"/federated/network/:network", wrapper.GetFederatedNetwork)
	router.GET(baseURL+"/federated/platform/:platform", wrapper.GetFederatedPlatform)
	router.GET(baseURL+"/federated/tx/:id", wrapper.GetFederatedTxID)
	router.GET(baseURL+"/federated/:account", wrapper.GetFederatedAccount)
	router.GET(baseURL+"/networks/config", wrapper.GetNetworksConfig)
	router.GET(baseURL+"/operators", wrapper.GetNodeOperatorInfo)
	router.GET(baseURL+"/operators/activity_count", wrapper.GetActivityCount)
	router.GET(baseURL+"/operators/info", wrapper.GetNodeInfo)
	router.GET(baseURL+"/operators/workers_status", wrapper.GetWorkersStatus)
	router.GET(baseURL+"/rss/:path", wrapper.GetRSS)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
