// Package docs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package docs

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	"github.com/rss3-network/node/schema/worker/decentralized"
	"github.com/rss3-network/node/schema/worker/federated"
	"github.com/rss3-network/protocol-go/schema"
	activityx "github.com/rss3-network/protocol-go/schema/activity"
	"github.com/rss3-network/protocol-go/schema/network"
	tag "github.com/rss3-network/protocol-go/schema/tag"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// PostDecentralizedAccountsJSONBody defines parameters for PostDecentralizedAccounts.
type PostDecentralizedAccountsJSONBody struct {
	// Accounts List of accounts to retrieve activities for
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor *string `json:"cursor,omitempty"`

	// Direction The direction of an activity.
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit int `json:"limit,omitempty"`

	// Network Retrieve activities from the specified network(s)
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag []tag.Tag `json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s)
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetDecentralizedNetworkNetworkParams defines parameters for GetDecentralizedNetworkNetwork.
type GetDecentralizedNetworkNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetDecentralizedPlatformPlatformParams defines parameters for GetDecentralizedPlatformPlatform.
type GetDecentralizedPlatformPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetDecentralizedTxIDParams defines parameters for GetDecentralizedTxID.
type GetDecentralizedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetDecentralizedAccountParams defines parameters for GetDecentralizedAccount.
type GetDecentralizedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostFederatedAccountsJSONBody defines parameters for PostFederatedAccounts.
type PostFederatedAccountsJSONBody struct {
	// Accounts List of accounts to retrieve activities for
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor *string `json:"cursor,omitempty"`

	// Direction The direction of an activity.
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit int `json:"limit,omitempty"`

	// Network Retrieve activities from the specified network(s)
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []federated.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag []tag.Tag `json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s)
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetFederatedNetworkNetworkParams defines parameters for GetFederatedNetworkNetwork.
type GetFederatedNetworkNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetFederatedPlatformPlatformParams defines parameters for GetFederatedPlatformPlatform.
type GetFederatedPlatformPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetFederatedTxIDParams defines parameters for GetFederatedTxID.
type GetFederatedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetFederatedAccountParams defines parameters for GetFederatedAccount.
type GetFederatedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostDecentralizedAccountsJSONRequestBody defines body for PostDecentralizedAccounts for application/json ContentType.
type PostDecentralizedAccountsJSONRequestBody PostDecentralizedAccountsJSONBody

// PostFederatedAccountsJSONRequestBody defines body for PostFederatedAccounts for application/json ContentType.
type PostFederatedAccountsJSONRequestBody PostFederatedAccountsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Node Operator Info
	// (GET /)
	Get(ctx echo.Context) error
	// Get Node Activity Count
	// (GET /activity_count)
	GetActivityCount(ctx echo.Context) error
	// Batch Get Accounts Activities
	// (POST /decentralized/accounts)
	PostDecentralizedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /decentralized/network/{network})
	GetDecentralizedNetworkNetwork(ctx echo.Context, network network.Network, params GetDecentralizedNetworkNetworkParams) error
	// Get Platform Activities
	// (GET /decentralized/platform/{platform})
	GetDecentralizedPlatformPlatform(ctx echo.Context, platform decentralized.Platform, params GetDecentralizedPlatformPlatformParams) error
	// Get Activity by ID
	// (GET /decentralized/tx/{id})
	GetDecentralizedTxID(ctx echo.Context, id string, params GetDecentralizedTxIDParams) error
	// Get Account Activities
	// (GET /decentralized/{account})
	GetDecentralizedAccount(ctx echo.Context, account string, params GetDecentralizedAccountParams) error
	// Batch Get Accounts Activities
	// (POST /federated/accounts)
	PostFederatedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /federated/network/{network})
	GetFederatedNetworkNetwork(ctx echo.Context, network network.Network, params GetFederatedNetworkNetworkParams) error
	// Get Platform Activities
	// (GET /federated/platform/{platform})
	GetFederatedPlatformPlatform(ctx echo.Context, platform federated.Platform, params GetFederatedPlatformPlatformParams) error
	// Get Activity by ID
	// (GET /federated/tx/{id})
	GetFederatedTxID(ctx echo.Context, id string, params GetFederatedTxIDParams) error
	// Get Account Activities
	// (GET /federated/{account})
	GetFederatedAccount(ctx echo.Context, account string, params GetFederatedAccountParams) error
	// Get worker config options
	// (GET /networks/config)
	GetNetworksConfig(ctx echo.Context) error
	// Get Node Status
	// (GET /operators/info)
	GetOperatorsInfo(ctx echo.Context) error
	// Get Node Worker Status
	// (GET /operators/workers_status)
	GetOperatorsWorkersStatus(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Get converts echo context to params.
func (w *ServerInterfaceWrapper) Get(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Get(ctx)
	return err
}

// GetActivityCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetActivityCount(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetActivityCount(ctx)
	return err
}

// PostDecentralizedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedAccounts(ctx)
	return err
}

// GetDecentralizedNetworkNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedNetworkNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedNetworkNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedNetworkNetwork(ctx, network, params)
	return err
}

// GetDecentralizedPlatformPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedPlatformPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform decentralized.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedPlatformPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedPlatformPlatform(ctx, platform, params)
	return err
}

// GetDecentralizedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedTxID(ctx, id, params)
	return err
}

// GetDecentralizedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedAccount(ctx, account, params)
	return err
}

// PostFederatedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostFederatedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFederatedAccounts(ctx)
	return err
}

// GetFederatedNetworkNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedNetworkNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedNetworkNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedNetworkNetwork(ctx, network, params)
	return err
}

// GetFederatedPlatformPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedPlatformPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform federated.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedPlatformPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedPlatformPlatform(ctx, platform, params)
	return err
}

// GetFederatedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedTxID(ctx, id, params)
	return err
}

// GetFederatedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedAccount(ctx, account, params)
	return err
}

// GetNetworksConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworksConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworksConfig(ctx)
	return err
}

// GetOperatorsInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetOperatorsInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOperatorsInfo(ctx)
	return err
}

// GetOperatorsWorkersStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetOperatorsWorkersStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOperatorsWorkersStatus(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/", wrapper.Get)
	router.GET(baseURL+"/activity_count", wrapper.GetActivityCount)
	router.POST(baseURL+"/decentralized/accounts", wrapper.PostDecentralizedAccounts)
	router.GET(baseURL+"/decentralized/network/:network", wrapper.GetDecentralizedNetworkNetwork)
	router.GET(baseURL+"/decentralized/platform/:platform", wrapper.GetDecentralizedPlatformPlatform)
	router.GET(baseURL+"/decentralized/tx/:id", wrapper.GetDecentralizedTxID)
	router.GET(baseURL+"/decentralized/:account", wrapper.GetDecentralizedAccount)
	router.POST(baseURL+"/federated/accounts", wrapper.PostFederatedAccounts)
	router.GET(baseURL+"/federated/network/:network", wrapper.GetFederatedNetworkNetwork)
	router.GET(baseURL+"/federated/platform/:platform", wrapper.GetFederatedPlatformPlatform)
	router.GET(baseURL+"/federated/tx/:id", wrapper.GetFederatedTxID)
	router.GET(baseURL+"/federated/:account", wrapper.GetFederatedAccount)
	router.GET(baseURL+"/networks/config", wrapper.GetNetworksConfig)
	router.GET(baseURL+"/operators/info", wrapper.GetOperatorsInfo)
	router.GET(baseURL+"/operators/workers_status", wrapper.GetOperatorsWorkersStatus)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"DQzvbnf/HwAA//9neBVHHpsAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
