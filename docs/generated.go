// Package docs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package docs

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/rss3-network/node/schema/worker/decentralized"
	"github.com/rss3-network/node/schema/worker/federated"
	"github.com/rss3-network/protocol-go/schema"
	activityx "github.com/rss3-network/protocol-go/schema/activity"
	"github.com/rss3-network/protocol-go/schema/network"
	"github.com/rss3-network/protocol-go/schema/tag"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// PostDecentralizedAccountsJSONBody defines parameters for PostDecentralizedAccounts.
type PostDecentralizedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   *int              `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag `json:"tag,omitempty"`
	Type []string  `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetDecentralizedNetworkParams defines parameters for GetDecentralizedNetwork.
type GetDecentralizedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// GetDecentralizedPlatformParams defines parameters for GetDecentralizedPlatform.
type GetDecentralizedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`
}

// GetDecentralizedTxIDParams defines parameters for GetDecentralizedTxID.
type GetDecentralizedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// ActionPage Specify the pagination for actions
	ActionPage *int `default:"1" form:"action_page,omitempty" json:"action_page,omitempty" query:"action_page" validate:"min=1"`
}

// GetDecentralizedAccountParams defines parameters for GetDecentralizedAccount.
type GetDecentralizedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// PostFederatedAccountsJSONBody defines parameters for PostFederatedAccounts.
type PostFederatedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   *int              `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []federated.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag `json:"tag,omitempty"`
	Type []string  `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetFederatedNetworkParams defines parameters for GetFederatedNetwork.
type GetFederatedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// GetFederatedPlatformParams defines parameters for GetFederatedPlatform.
type GetFederatedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`
}

// GetFederatedTxIDParams defines parameters for GetFederatedTxID.
type GetFederatedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// ActionPage Specify the pagination for actions
	ActionPage *int `default:"1" form:"action_page,omitempty" json:"action_page,omitempty" query:"action_page" validate:"min=1"`
}

// GetFederatedAccountParams defines parameters for GetFederatedAccount.
type GetFederatedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// PostDecentralizedAccountsJSONRequestBody defines body for PostDecentralizedAccounts for application/json ContentType.
type PostDecentralizedAccountsJSONRequestBody PostDecentralizedAccountsJSONBody

// PostFederatedAccountsJSONRequestBody defines body for PostFederatedAccounts for application/json ContentType.
type PostFederatedAccountsJSONRequestBody PostFederatedAccountsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Batch Get Accounts Activities
	// (POST /decentralized/accounts)
	PostDecentralizedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /decentralized/network/{network})
	GetDecentralizedNetwork(ctx echo.Context, network network.Network, params GetDecentralizedNetworkParams) error
	// Get Platform Activities
	// (GET /decentralized/platform/{platform})
	GetDecentralizedPlatform(ctx echo.Context, platform decentralized.Platform, params GetDecentralizedPlatformParams) error
	// Get Activity by ID
	// (GET /decentralized/tx/{id})
	GetDecentralizedTxID(ctx echo.Context, id string, params GetDecentralizedTxIDParams) error
	// Get Account Activities
	// (GET /decentralized/{account})
	GetDecentralizedAccount(ctx echo.Context, account string, params GetDecentralizedAccountParams) error
	// Batch Get Accounts Activities
	// (POST /federated/accounts)
	PostFederatedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /federated/network/{network})
	GetFederatedNetwork(ctx echo.Context, network network.Network, params GetFederatedNetworkParams) error
	// Get Platform Activities
	// (GET /federated/platform/{platform})
	GetFederatedPlatform(ctx echo.Context, platform federated.Platform, params GetFederatedPlatformParams) error
	// Get Activity by ID
	// (GET /federated/tx/{id})
	GetFederatedTxID(ctx echo.Context, id string, params GetFederatedTxIDParams) error
	// Get Account Activities
	// (GET /federated/{account})
	GetFederatedAccount(ctx echo.Context, account string, params GetFederatedAccountParams) error
	// Get worker config options
	// (GET /networks/config)
	GetNetworksConfig(ctx echo.Context) error
	// Get Node Operator Info
	// (GET /operators)
	GetNodeOperatorInfo(ctx echo.Context) error
	// Get Node Activity Count
	// (GET /operators/activity_count)
	GetActivityCount(ctx echo.Context) error
	// Get Node Status
	// (GET /operators/info)
	GetNodeInfo(ctx echo.Context) error
	// Get Node Worker Status
	// (GET /operators/workers_status)
	GetWorkersStatus(ctx echo.Context) error
	// Get RSS Activity by Path
	// (GET /rss/{path})
	GetRSS(ctx echo.Context, path string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostDecentralizedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedAccounts(ctx)
	return err
}

// GetDecentralizedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	//err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "network", &network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedNetworkParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedNetwork(ctx, network, params)
	return err
}

// GetDecentralizedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform decentralized.Platform

	//err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "platform", &platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedPlatformParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedPlatform(ctx, platform, params)
	return err
}

// GetDecentralizedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	//err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "id", &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedTxIDParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedTxID(ctx, id, params)
	return err
}

// GetDecentralizedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	//err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "account", &account)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedAccountParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedAccount(ctx, account, params)
	return err
}

// PostFederatedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostFederatedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFederatedAccounts(ctx)
	return err
}

// GetFederatedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	//err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "network", &network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedNetworkParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedNetwork(ctx, network, params)
	return err
}

// GetFederatedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform federated.Platform

	//err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "platform", &platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedPlatformParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedPlatform(ctx, platform, params)
	return err
}

// GetFederatedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	//err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "id", &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedTxIDParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedTxID(ctx, id, params)
	return err
}

// GetFederatedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	//err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "account", &account)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedAccountParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedAccount(ctx, account, params)
	return err
}

// GetNetworksConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworksConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworksConfig(ctx)
	return err
}

// GetNodeOperatorInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeOperatorInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeOperatorInfo(ctx)
	return err
}

// GetActivityCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetActivityCount(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetActivityCount(ctx)
	return err
}

// GetNodeInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeInfo(ctx)
	return err
}

// GetWorkersStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkersStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkersStatus(ctx)
	return err
}

// GetRSS converts echo context to params.
func (w *ServerInterfaceWrapper) GetRSS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	//err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "path", &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRSS(ctx, path)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/decentralized/accounts", wrapper.PostDecentralizedAccounts)
	router.GET(baseURL+"/decentralized/network/:network", wrapper.GetDecentralizedNetwork)
	router.GET(baseURL+"/decentralized/platform/:platform", wrapper.GetDecentralizedPlatform)
	router.GET(baseURL+"/decentralized/tx/:id", wrapper.GetDecentralizedTxID)
	router.GET(baseURL+"/decentralized/:account", wrapper.GetDecentralizedAccount)
	router.POST(baseURL+"/federated/accounts", wrapper.PostFederatedAccounts)
	router.GET(baseURL+"/federated/network/:network", wrapper.GetFederatedNetwork)
	router.GET(baseURL+"/federated/platform/:platform", wrapper.GetFederatedPlatform)
	router.GET(baseURL+"/federated/tx/:id", wrapper.GetFederatedTxID)
	router.GET(baseURL+"/federated/:account", wrapper.GetFederatedAccount)
	router.GET(baseURL+"/networks/config", wrapper.GetNetworksConfig)
	router.GET(baseURL+"/operators", wrapper.GetNodeOperatorInfo)
	router.GET(baseURL+"/operators/activity_count", wrapper.GetActivityCount)
	router.GET(baseURL+"/operators/info", wrapper.GetNodeInfo)
	router.GET(baseURL+"/operators/workers_status", wrapper.GetWorkersStatus)
	router.GET(baseURL+"/rss/:path", wrapper.GetRSS)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
