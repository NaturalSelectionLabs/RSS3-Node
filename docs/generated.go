// Package docs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package docs

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/rss3-network/node/schema/worker/decentralized"
	"github.com/rss3-network/node/schema/worker/federated"
	"github.com/rss3-network/protocol-go/schema"
	activityx "github.com/rss3-network/protocol-go/schema/activity"
	"github.com/rss3-network/protocol-go/schema/network"
	"github.com/rss3-network/protocol-go/schema/tag"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// PostDecentralizedAccountsJSONBody defines parameters for PostDecentralizedAccounts.
type PostDecentralizedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   *int              `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag `json:"tag,omitempty"`
	Type []string  `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetDecentralizedNetworkParams defines parameters for GetDecentralizedNetwork.
type GetDecentralizedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// GetDecentralizedPlatformParams defines parameters for GetDecentralizedPlatform.
type GetDecentralizedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`
}

// GetDecentralizedTxIDParams defines parameters for GetDecentralizedTxID.
type GetDecentralizedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// ActionPage Specify the pagination for actions
	ActionPage *int `default:"1" form:"action_page,omitempty" json:"action_page,omitempty" query:"action_page" validate:"min=1"`
}

// GetDecentralizedAccountParams defines parameters for GetDecentralizedAccount.
type GetDecentralizedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// PostFederatedAccountsJSONBody defines parameters for PostFederatedAccounts.
type PostFederatedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   *int              `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []federated.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag `json:"tag,omitempty"`
	Type []string  `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetFederatedNetworkParams defines parameters for GetFederatedNetwork.
type GetFederatedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// GetFederatedPlatformParams defines parameters for GetFederatedPlatform.
type GetFederatedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`
}

// GetFederatedTxIDParams defines parameters for GetFederatedTxID.
type GetFederatedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// ActionPage Specify the pagination for actions
	ActionPage *int `default:"1" form:"action_page,omitempty" json:"action_page,omitempty" query:"action_page" validate:"min=1"`
}

// GetFederatedAccountParams defines parameters for GetFederatedAccount.
type GetFederatedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// PostDecentralizedAccountsJSONRequestBody defines body for PostDecentralizedAccounts for application/json ContentType.
type PostDecentralizedAccountsJSONRequestBody PostDecentralizedAccountsJSONBody

// PostFederatedAccountsJSONRequestBody defines body for PostFederatedAccounts for application/json ContentType.
type PostFederatedAccountsJSONRequestBody PostFederatedAccountsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Batch Get Accounts Activities
	// (POST /decentralized/accounts)
	PostDecentralizedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /decentralized/network/{network})
	GetDecentralizedNetwork(ctx echo.Context, network network.Network, params GetDecentralizedNetworkParams) error
	// Get Platform Activities
	// (GET /decentralized/platform/{platform})
	GetDecentralizedPlatform(ctx echo.Context, platform decentralized.Platform, params GetDecentralizedPlatformParams) error
	// Get Activity by ID
	// (GET /decentralized/tx/{id})
	GetDecentralizedTxID(ctx echo.Context, id string, params GetDecentralizedTxIDParams) error
	// Get Account Activities
	// (GET /decentralized/{account})
	GetDecentralizedAccount(ctx echo.Context, account string, params GetDecentralizedAccountParams) error
	// Batch Get Accounts Activities
	// (POST /federated/accounts)
	PostFederatedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /federated/network/{network})
	GetFederatedNetwork(ctx echo.Context, network network.Network, params GetFederatedNetworkParams) error
	// Get Platform Activities
	// (GET /federated/platform/{platform})
	GetFederatedPlatform(ctx echo.Context, platform federated.Platform, params GetFederatedPlatformParams) error
	// Get Activity by ID
	// (GET /federated/tx/{id})
	GetFederatedTxID(ctx echo.Context, id string, params GetFederatedTxIDParams) error
	// Get Account Activities
	// (GET /federated/{account})
	GetFederatedAccount(ctx echo.Context, account string, params GetFederatedAccountParams) error
	// Get worker config options
	// (GET /networks/config)
	GetNetworksConfig(ctx echo.Context) error
	// Get Node Operator Info
	// (GET /operators)
	GetNodeOperatorInfo(ctx echo.Context) error
	// Get Node Activity Count
	// (GET /operators/activity_count)
	GetActivityCount(ctx echo.Context) error
	// Get Node Status
	// (GET /operators/info)
	GetNodeInfo(ctx echo.Context) error
	// Get Node Worker Status
	// (GET /operators/workers_status)
	GetWorkersStatus(ctx echo.Context) error
	// Get RSS Activity by Path
	// (GET /rss/{path})
	GetRSS(ctx echo.Context, path string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostDecentralizedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedAccounts(ctx)
	return err
}

// GetDecentralizedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	//err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "network", &network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedNetworkParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedNetwork(ctx, network, params)
	return err
}

// GetDecentralizedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform decentralized.Platform

	//err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "platform", &platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedPlatformParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedPlatform(ctx, platform, params)
	return err
}

// GetDecentralizedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	//err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "id", &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedTxIDParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedTxID(ctx, id, params)
	return err
}

// GetDecentralizedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	//err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "account", &account)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedAccountParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedAccount(ctx, account, params)
	return err
}

// PostFederatedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostFederatedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFederatedAccounts(ctx)
	return err
}

// GetFederatedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	//err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "network", &network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedNetworkParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedNetwork(ctx, network, params)
	return err
}

// GetFederatedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform federated.Platform

	//err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "platform", &platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedPlatformParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedPlatform(ctx, platform, params)
	return err
}

// GetFederatedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	//err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "id", &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedTxIDParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedTxID(ctx, id, params)
	return err
}

// GetFederatedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	//err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "account", &account)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedAccountParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedAccount(ctx, account, params)
	return err
}

// GetNetworksConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworksConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworksConfig(ctx)
	return err
}

// GetNodeOperatorInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeOperatorInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeOperatorInfo(ctx)
	return err
}

// GetActivityCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetActivityCount(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetActivityCount(ctx)
	return err
}

// GetNodeInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeInfo(ctx)
	return err
}

// GetWorkersStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkersStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkersStatus(ctx)
	return err
}

// GetRSS converts echo context to params.
func (w *ServerInterfaceWrapper) GetRSS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	//err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "path", &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRSS(ctx, path)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/decentralized/accounts", wrapper.PostDecentralizedAccounts)
	router.GET(baseURL+"/decentralized/network/:network", wrapper.GetDecentralizedNetwork)
	router.GET(baseURL+"/decentralized/platform/:platform", wrapper.GetDecentralizedPlatform)
	router.GET(baseURL+"/decentralized/tx/:id", wrapper.GetDecentralizedTxID)
	router.GET(baseURL+"/decentralized/:account", wrapper.GetDecentralizedAccount)
	router.POST(baseURL+"/federated/accounts", wrapper.PostFederatedAccounts)
	router.GET(baseURL+"/federated/network/:network", wrapper.GetFederatedNetwork)
	router.GET(baseURL+"/federated/platform/:platform", wrapper.GetFederatedPlatform)
	router.GET(baseURL+"/federated/tx/:id", wrapper.GetFederatedTxID)
	router.GET(baseURL+"/federated/:account", wrapper.GetFederatedAccount)
	router.GET(baseURL+"/networks/config", wrapper.GetNetworksConfig)
	router.GET(baseURL+"/operators", wrapper.GetNodeOperatorInfo)
	router.GET(baseURL+"/operators/activity_count", wrapper.GetActivityCount)
	router.GET(baseURL+"/operators/info", wrapper.GetNodeInfo)
	router.GET(baseURL+"/operators/workers_status", wrapper.GetWorkersStatus)
	router.GET(baseURL+"/rss/:path", wrapper.GetRSS)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
