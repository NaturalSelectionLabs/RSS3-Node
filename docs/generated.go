// Package docs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package docs

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	"github.com/rss3-network/node/schema/worker/decentralized"
	"github.com/rss3-network/node/schema/worker/federated"
	"github.com/rss3-network/protocol-go/schema"
	activityx "github.com/rss3-network/protocol-go/schema/activity"
	"github.com/rss3-network/protocol-go/schema/network"
	tag "github.com/rss3-network/protocol-go/schema/tag"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// PostDecentralizedAccountsJSONBody defines parameters for PostDecentralizedAccounts.
type PostDecentralizedAccountsJSONBody struct {
	// Accounts List of accounts to retrieve activities for
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   int               `json:"limit,omitempty"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag     `json:"tag,omitempty"`
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetDecentralizedNetworkNetworkParams defines parameters for GetDecentralizedNetworkNetwork.
type GetDecentralizedNetworkNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetDecentralizedPlatformPlatformParams defines parameters for GetDecentralizedPlatformPlatform.
type GetDecentralizedPlatformPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetDecentralizedTxIDParams defines parameters for GetDecentralizedTxID.
type GetDecentralizedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetDecentralizedAccountParams defines parameters for GetDecentralizedAccount.
type GetDecentralizedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostFederatedAccountsJSONBody defines parameters for PostFederatedAccounts.
type PostFederatedAccountsJSONBody struct {
	// Accounts List of accounts to retrieve activities for
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   int               `json:"limit,omitempty"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []federated.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag     `json:"tag,omitempty"`
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetFederatedNetworkNetworkParams defines parameters for GetFederatedNetworkNetwork.
type GetFederatedNetworkNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetFederatedPlatformPlatformParams defines parameters for GetFederatedPlatformPlatform.
type GetFederatedPlatformPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetFederatedTxIDParams defines parameters for GetFederatedTxID.
type GetFederatedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetFederatedAccountParams defines parameters for GetFederatedAccount.
type GetFederatedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostDecentralizedAccountsJSONRequestBody defines body for PostDecentralizedAccounts for application/json ContentType.
type PostDecentralizedAccountsJSONRequestBody PostDecentralizedAccountsJSONBody

// PostFederatedAccountsJSONRequestBody defines body for PostFederatedAccounts for application/json ContentType.
type PostFederatedAccountsJSONRequestBody PostFederatedAccountsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Node Operator Info
	// (GET /)
	GetNodeOperatorInfo(ctx echo.Context) error
	// Get Node Activity Count
	// (GET /activity_count)
	GetActivityCount(ctx echo.Context) error
	// Batch Get Accounts Activities
	// (POST /decentralized/accounts)
	PostDecentralizedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /decentralized/network/{network})
	GetDecentralizedNetworkNetwork(ctx echo.Context, network network.Network, params GetDecentralizedNetworkNetworkParams) error
	// Get Platform Activities
	// (GET /decentralized/platform/{platform})
	GetDecentralizedPlatformPlatform(ctx echo.Context, platform decentralized.Platform, params GetDecentralizedPlatformPlatformParams) error
	// Get Activity by ID
	// (GET /decentralized/tx/{id})
	GetDecentralizedTxID(ctx echo.Context, id string, params GetDecentralizedTxIDParams) error
	// Get Account Activities
	// (GET /decentralized/{account})
	GetDecentralizedAccount(ctx echo.Context, account string, params GetDecentralizedAccountParams) error
	// Batch Get Accounts Activities
	// (POST /federated/accounts)
	PostFederatedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /federated/network/{network})
	GetFederatedNetworkNetwork(ctx echo.Context, network network.Network, params GetFederatedNetworkNetworkParams) error
	// Get Platform Activities
	// (GET /federated/platform/{platform})
	GetFederatedPlatformPlatform(ctx echo.Context, platform federated.Platform, params GetFederatedPlatformPlatformParams) error
	// Get Activity by ID
	// (GET /federated/tx/{id})
	GetFederatedTxID(ctx echo.Context, id string, params GetFederatedTxIDParams) error
	// Get Account Activities
	// (GET /federated/{account})
	GetFederatedAccount(ctx echo.Context, account string, params GetFederatedAccountParams) error
	// Get worker config options
	// (GET /networks/config)
	GetNetworksConfig(ctx echo.Context) error
	// Get Node Status
	// (GET /operators/info)
	GetNodeInfo(ctx echo.Context) error
	// Get Node Worker Status
	// (GET /operators/workers_status)
	GetWorkersStatus(ctx echo.Context) error
	// Get RSS Activity by Path
	// (GET /rss/{path})
	GetRSS(ctx echo.Context, path string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetNodeOperatorInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeOperatorInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeOperatorInfo(ctx)
	return err
}

// GetActivityCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetActivityCount(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetActivityCount(ctx)
	return err
}

// PostDecentralizedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedAccounts(ctx)
	return err
}

// GetDecentralizedNetworkNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedNetworkNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedNetworkNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedNetworkNetwork(ctx, network, params)
	return err
}

// GetDecentralizedPlatformPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedPlatformPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform decentralized.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedPlatformPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedPlatformPlatform(ctx, platform, params)
	return err
}

// GetDecentralizedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedTxID(ctx, id, params)
	return err
}

// GetDecentralizedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedAccount(ctx, account, params)
	return err
}

// PostFederatedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostFederatedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFederatedAccounts(ctx)
	return err
}

// GetFederatedNetworkNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedNetworkNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedNetworkNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedNetworkNetwork(ctx, network, params)
	return err
}

// GetFederatedPlatformPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedPlatformPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform federated.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedPlatformPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedPlatformPlatform(ctx, platform, params)
	return err
}

// GetFederatedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedTxID(ctx, id, params)
	return err
}

// GetFederatedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedAccount(ctx, account, params)
	return err
}

// GetNetworksConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworksConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworksConfig(ctx)
	return err
}

// GetNodeInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeInfo(ctx)
	return err
}

// GetWorkersStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkersStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkersStatus(ctx)
	return err
}

// GetRSS converts echo context to params.
func (w *ServerInterfaceWrapper) GetRSS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRSS(ctx, path)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/", wrapper.GetNodeOperatorInfo)
	router.GET(baseURL+"/activity_count", wrapper.GetActivityCount)
	router.POST(baseURL+"/decentralized/accounts", wrapper.PostDecentralizedAccounts)
	router.GET(baseURL+"/decentralized/network/:network", wrapper.GetDecentralizedNetworkNetwork)
	router.GET(baseURL+"/decentralized/platform/:platform", wrapper.GetDecentralizedPlatformPlatform)
	router.GET(baseURL+"/decentralized/tx/:id", wrapper.GetDecentralizedTxID)
	router.GET(baseURL+"/decentralized/:account", wrapper.GetDecentralizedAccount)
	router.POST(baseURL+"/federated/accounts", wrapper.PostFederatedAccounts)
	router.GET(baseURL+"/federated/network/:network", wrapper.GetFederatedNetworkNetwork)
	router.GET(baseURL+"/federated/platform/:platform", wrapper.GetFederatedPlatformPlatform)
	router.GET(baseURL+"/federated/tx/:id", wrapper.GetFederatedTxID)
	router.GET(baseURL+"/federated/:account", wrapper.GetFederatedAccount)
	router.GET(baseURL+"/networks/config", wrapper.GetNetworksConfig)
	router.GET(baseURL+"/operators/info", wrapper.GetNodeInfo)
	router.GET(baseURL+"/operators/workers_status", wrapper.GetWorkersStatus)
	router.GET(baseURL+"/rss/:path", wrapper.GetRSS)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
