// Package docs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package docs

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/rss3-network/node/schema/worker/decentralized"
	"github.com/rss3-network/node/schema/worker/federated"
	"github.com/rss3-network/protocol-go/schema"
	activityx "github.com/rss3-network/protocol-go/schema/activity"
	"github.com/rss3-network/protocol-go/schema/network"
	"github.com/rss3-network/protocol-go/schema/tag"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// PostDecentralizedAccountsJSONBody defines parameters for PostDecentralizedAccounts.
type PostDecentralizedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   *int              `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag `json:"tag,omitempty"`
	Type []string  `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetDecentralizedNetworkParams defines parameters for GetDecentralizedNetwork.
type GetDecentralizedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// GetDecentralizedPlatformParams defines parameters for GetDecentralizedPlatform.
type GetDecentralizedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`
}

// GetDecentralizedTxIDParams defines parameters for GetDecentralizedTxID.
type GetDecentralizedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// ActionPage Specify the pagination for actions
	ActionPage *int `default:"1" form:"action_page,omitempty" json:"action_page,omitempty" query:"action_page" validate:"min=1"`
}

// GetDecentralizedAccountParams defines parameters for GetDecentralizedAccount.
type GetDecentralizedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// PostFederatedAccountsJSONBody defines parameters for PostFederatedAccounts.
type PostFederatedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   *int              `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []federated.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag `json:"tag,omitempty"`
	Type []string  `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetFederatedNetworkParams defines parameters for GetFederatedNetwork.
type GetFederatedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// GetFederatedPlatformParams defines parameters for GetFederatedPlatform.
type GetFederatedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`
}

// GetFederatedTxIDParams defines parameters for GetFederatedTxID.
type GetFederatedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// ActionPage Specify the pagination for actions
	ActionPage *int `default:"1" form:"action_page,omitempty" json:"action_page,omitempty" query:"action_page" validate:"min=1"`
}

// GetFederatedAccountParams defines parameters for GetFederatedAccount.
type GetFederatedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// PostDecentralizedAccountsJSONRequestBody defines body for PostDecentralizedAccounts for application/json ContentType.
type PostDecentralizedAccountsJSONRequestBody PostDecentralizedAccountsJSONBody

// PostFederatedAccountsJSONRequestBody defines body for PostFederatedAccounts for application/json ContentType.
type PostFederatedAccountsJSONRequestBody PostFederatedAccountsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Node Operator Info
	// (GET /)
	GetNodeOperatorInfo(ctx echo.Context) error
	// Get Node Activity Count
	// (GET /activity_count)
	GetActivityCount(ctx echo.Context) error
	// Batch Get Accounts Activities
	// (POST /decentralized/accounts)
	PostDecentralizedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /decentralized/network/{network})
	GetDecentralizedNetwork(ctx echo.Context, network network.Network, params GetDecentralizedNetworkParams) error
	// Get Platform Activities
	// (GET /decentralized/platform/{platform})
	GetDecentralizedPlatform(ctx echo.Context, platform decentralized.Platform, params GetDecentralizedPlatformParams) error
	// Get Activity by ID
	// (GET /decentralized/tx/{id})
	GetDecentralizedTxID(ctx echo.Context, id string, params GetDecentralizedTxIDParams) error
	// Get Account Activities
	// (GET /decentralized/{account})
	GetDecentralizedAccount(ctx echo.Context, account string, params GetDecentralizedAccountParams) error
	// Batch Get Accounts Activities
	// (POST /federated/accounts)
	PostFederatedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /federated/network/{network})
	GetFederatedNetwork(ctx echo.Context, network network.Network, params GetFederatedNetworkParams) error
	// Get Platform Activities
	// (GET /federated/platform/{platform})
	GetFederatedPlatform(ctx echo.Context, platform federated.Platform, params GetFederatedPlatformParams) error
	// Get Activity by ID
	// (GET /federated/tx/{id})
	GetFederatedTxID(ctx echo.Context, id string, params GetFederatedTxIDParams) error
	// Get Account Activities
	// (GET /federated/{account})
	GetFederatedAccount(ctx echo.Context, account string, params GetFederatedAccountParams) error
	// Get worker config options
	// (GET /networks/config)
	GetNetworksConfig(ctx echo.Context) error
	// Get Node Status
	// (GET /operators/info)
	GetNodeInfo(ctx echo.Context) error
	// Get Node Worker Status
	// (GET /operators/workers_status)
	GetWorkersStatus(ctx echo.Context) error
	// Get RSS Activity by Path
	// (GET /rss/{path})
	GetRSS(ctx echo.Context, path string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetNodeOperatorInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeOperatorInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeOperatorInfo(ctx)
	return err
}

// GetActivityCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetActivityCount(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetActivityCount(ctx)
	return err
}

// PostDecentralizedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedAccounts(ctx)
	return err
}

// GetDecentralizedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	//err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "network", &network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedNetworkParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedNetwork(ctx, network, params)
	return err
}

// GetDecentralizedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform decentralized.Platform

	//err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "platform", &platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedPlatformParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedPlatform(ctx, platform, params)
	return err
}

// GetDecentralizedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	//err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "id", &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedTxIDParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedTxID(ctx, id, params)
	return err
}

// GetDecentralizedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	//err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "account", &account)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedAccountParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedAccount(ctx, account, params)
	return err
}

// PostFederatedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostFederatedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFederatedAccounts(ctx)
	return err
}

// GetFederatedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	//err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "network", &network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedNetworkParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedNetwork(ctx, network, params)
	return err
}

// GetFederatedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform federated.Platform

	//err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "platform", &platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedPlatformParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedPlatform(ctx, platform, params)
	return err
}

// GetFederatedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	//err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "id", &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedTxIDParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedTxID(ctx, id, params)
	return err
}

// GetFederatedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	//err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "account", &account)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedAccountParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedAccount(ctx, account, params)
	return err
}

// GetNetworksConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworksConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworksConfig(ctx)
	return err
}

// GetNodeInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeInfo(ctx)
	return err
}

// GetWorkersStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkersStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkersStatus(ctx)
	return err
}

// GetRSS converts echo context to params.
func (w *ServerInterfaceWrapper) GetRSS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	//err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "path", &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRSS(ctx, path)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/", wrapper.GetNodeOperatorInfo)
	router.GET(baseURL+"/activity_count", wrapper.GetActivityCount)
	router.POST(baseURL+"/decentralized/accounts", wrapper.PostDecentralizedAccounts)
	router.GET(baseURL+"/decentralized/network/:network", wrapper.GetDecentralizedNetwork)
	router.GET(baseURL+"/decentralized/platform/:platform", wrapper.GetDecentralizedPlatform)
	router.GET(baseURL+"/decentralized/tx/:id", wrapper.GetDecentralizedTxID)
	router.GET(baseURL+"/decentralized/:account", wrapper.GetDecentralizedAccount)
	router.POST(baseURL+"/federated/accounts", wrapper.PostFederatedAccounts)
	router.GET(baseURL+"/federated/network/:network", wrapper.GetFederatedNetwork)
	router.GET(baseURL+"/federated/platform/:platform", wrapper.GetFederatedPlatform)
	router.GET(baseURL+"/federated/tx/:id", wrapper.GetFederatedTxID)
	router.GET(baseURL+"/federated/:account", wrapper.GetFederatedAccount)
	router.GET(baseURL+"/networks/config", wrapper.GetNetworksConfig)
	router.GET(baseURL+"/operators/info", wrapper.GetNodeInfo)
	router.GET(baseURL+"/operators/workers_status", wrapper.GetWorkersStatus)
	router.GET(baseURL+"/rss/:path", wrapper.GetRSS)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
