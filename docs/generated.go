// Package docs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package docs

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	"github.com/rss3-network/node/schema/worker/decentralized"
	"github.com/rss3-network/node/schema/worker/federated"
	"github.com/rss3-network/protocol-go/schema"
	activityx "github.com/rss3-network/protocol-go/schema/activity"
	"github.com/rss3-network/protocol-go/schema/network"
	tag "github.com/rss3-network/protocol-go/schema/tag"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// PostDecentralizedAccountsJSONBody defines parameters for PostDecentralizedAccounts.
type PostDecentralizedAccountsJSONBody struct {
	Accounts *interface{} `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   int               `json:"limit,omitempty"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag     `json:"tag,omitempty"`
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetDecentralizedNetworkParams defines parameters for GetDecentralizedNetwork.
type GetDecentralizedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetDecentralizedPlatformParams defines parameters for GetDecentralizedPlatform.
type GetDecentralizedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetDecentralizedTxIDParams defines parameters for GetDecentralizedTxID.
type GetDecentralizedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetDecentralizedAccountParams defines parameters for GetDecentralizedAccount.
type GetDecentralizedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostFederatedAccountsJSONBody defines parameters for PostFederatedAccounts.
type PostFederatedAccountsJSONBody struct {
	Accounts *interface{} `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   int               `json:"limit,omitempty"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []federated.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag     `json:"tag,omitempty"`
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetFederatedNetworkParams defines parameters for GetFederatedNetwork.
type GetFederatedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetFederatedPlatformParams defines parameters for GetFederatedPlatform.
type GetFederatedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetFederatedTxIDParams defines parameters for GetFederatedTxID.
type GetFederatedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetFederatedAccountParams defines parameters for GetFederatedAccount.
type GetFederatedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostDecentralizedAccountsJSONRequestBody defines body for PostDecentralizedAccounts for application/json ContentType.
type PostDecentralizedAccountsJSONRequestBody PostDecentralizedAccountsJSONBody

// PostFederatedAccountsJSONRequestBody defines body for PostFederatedAccounts for application/json ContentType.
type PostFederatedAccountsJSONRequestBody PostFederatedAccountsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Node Operator Info
	// (GET /)
	GetNodeOperatorInfo(ctx echo.Context) error
	// Get Node Activity Count
	// (GET /activity_count)
	GetActivityCount(ctx echo.Context) error
	// Batch Get Accounts Activities
	// (POST /decentralized/accounts)
	PostDecentralizedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /decentralized/network/{network})
	GetDecentralizedNetwork(ctx echo.Context, network network.Network, params GetDecentralizedNetworkParams) error
	// Get Platform Activities
	// (GET /decentralized/platform/{platform})
	GetDecentralizedPlatform(ctx echo.Context, platform decentralized.Platform, params GetDecentralizedPlatformParams) error
	// Get Activity by ID
	// (GET /decentralized/tx/{id})
	GetDecentralizedTxID(ctx echo.Context, id string, params GetDecentralizedTxIDParams) error
	// Get Account Activities
	// (GET /decentralized/{account})
	GetDecentralizedAccount(ctx echo.Context, account string, params GetDecentralizedAccountParams) error
	// Batch Get Accounts Activities
	// (POST /federated/accounts)
	PostFederatedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /federated/network/{network})
	GetFederatedNetwork(ctx echo.Context, network network.Network, params GetFederatedNetworkParams) error
	// Get Platform Activities
	// (GET /federated/platform/{platform})
	GetFederatedPlatform(ctx echo.Context, platform federated.Platform, params GetFederatedPlatformParams) error
	// Get Activity by ID
	// (GET /federated/tx/{id})
	GetFederatedTxID(ctx echo.Context, id string, params GetFederatedTxIDParams) error
	// Get Account Activities
	// (GET /federated/{account})
	GetFederatedAccount(ctx echo.Context, account string, params GetFederatedAccountParams) error
	// Get worker config options
	// (GET /networks/config)
	GetNetworksConfig(ctx echo.Context) error
	// Get Node Status
	// (GET /operators/info)
	GetNodeInfo(ctx echo.Context) error
	// Get Node Worker Status
	// (GET /operators/workers_status)
	GetWorkersStatus(ctx echo.Context) error
	// Get RSS Activity by Path
	// (GET /rss/{path})
	GetRSS(ctx echo.Context, path string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetNodeOperatorInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeOperatorInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeOperatorInfo(ctx)
	return err
}

// GetActivityCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetActivityCount(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetActivityCount(ctx)
	return err
}

// PostDecentralizedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedAccounts(ctx)
	return err
}

// GetDecentralizedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedNetwork(ctx, network, params)
	return err
}

// GetDecentralizedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform decentralized.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedPlatform(ctx, platform, params)
	return err
}

// GetDecentralizedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedTxID(ctx, id, params)
	return err
}

// GetDecentralizedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedAccount(ctx, account, params)
	return err
}

// PostFederatedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostFederatedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFederatedAccounts(ctx)
	return err
}

// GetFederatedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedNetwork(ctx, network, params)
	return err
}

// GetFederatedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform federated.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedPlatform(ctx, platform, params)
	return err
}

// GetFederatedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedTxID(ctx, id, params)
	return err
}

// GetFederatedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedAccount(ctx, account, params)
	return err
}

// GetNetworksConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworksConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworksConfig(ctx)
	return err
}

// GetNodeInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeInfo(ctx)
	return err
}

// GetWorkersStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkersStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkersStatus(ctx)
	return err
}

// GetRSS converts echo context to params.
func (w *ServerInterfaceWrapper) GetRSS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRSS(ctx, path)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/", wrapper.GetNodeOperatorInfo)
	router.GET(baseURL+"/activity_count", wrapper.GetActivityCount)
	router.POST(baseURL+"/decentralized/accounts", wrapper.PostDecentralizedAccounts)
	router.GET(baseURL+"/decentralized/network/:network", wrapper.GetDecentralizedNetwork)
	router.GET(baseURL+"/decentralized/platform/:platform", wrapper.GetDecentralizedPlatform)
	router.GET(baseURL+"/decentralized/tx/:id", wrapper.GetDecentralizedTxID)
	router.GET(baseURL+"/decentralized/:account", wrapper.GetDecentralizedAccount)
	router.POST(baseURL+"/federated/accounts", wrapper.PostFederatedAccounts)
	router.GET(baseURL+"/federated/network/:network", wrapper.GetFederatedNetwork)
	router.GET(baseURL+"/federated/platform/:platform", wrapper.GetFederatedPlatform)
	router.GET(baseURL+"/federated/tx/:id", wrapper.GetFederatedTxID)
	router.GET(baseURL+"/federated/:account", wrapper.GetFederatedAccount)
	router.GET(baseURL+"/networks/config", wrapper.GetNetworksConfig)
	router.GET(baseURL+"/operators/info", wrapper.GetNodeInfo)
	router.GET(baseURL+"/operators/workers_status", wrapper.GetWorkersStatus)
	router.GET(baseURL+"/rss/:path", wrapper.GetRSS)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
