// Package docs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package docs

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/rss3-network/node/schema/worker/decentralized"
	"github.com/rss3-network/node/schema/worker/federated"
	"github.com/rss3-network/protocol-go/schema"
	activityx "github.com/rss3-network/protocol-go/schema/activity"
	"github.com/rss3-network/protocol-go/schema/metadata"
	"github.com/rss3-network/protocol-go/schema/network"
	"github.com/rss3-network/protocol-go/schema/tag"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// PostDecentralizedAccountsJSONBody defines parameters for PostDecentralizedAccounts.
type PostDecentralizedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   *int              `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag `json:"tag,omitempty"`
	Type []string  `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// PostDecentralizedMetadataJSONBody defines parameters for PostDecentralizedMetadata.
type PostDecentralizedMetadataJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor *string `json:"cursor,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit    *int                    `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`
	Metadata *metadata.Metadata      `json:"metadata,omitempty" validate:"required"`
	Network  *network.Network        `json:"network,omitempty" validate:"required"`
	Platform *decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool        `json:"success,omitempty"`
	Tag    *tag.Tag     `json:"tag,omitempty" validate:"required"`
	Type   *schema.Type `json:"type,omitempty" validate:"required"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetDecentralizedNetworkParams defines parameters for GetDecentralizedNetwork.
type GetDecentralizedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// GetDecentralizedPlatformParams defines parameters for GetDecentralizedPlatform.
type GetDecentralizedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`
}

// GetDecentralizedTxIDParams defines parameters for GetDecentralizedTxID.
type GetDecentralizedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// ActionPage Specify the pagination for actions
	ActionPage *int `default:"1" form:"action_page,omitempty" json:"action_page,omitempty" query:"action_page" validate:"min=1"`
}

// GetDecentralizedAccountParams defines parameters for GetDecentralizedAccount.
type GetDecentralizedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// PostFederatedAccountsJSONBody defines parameters for PostFederatedAccounts.
type PostFederatedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit *int `default:"10" json:"action_limit,omitempty" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   *int              `default:"100" json:"limit,omitempty" validate:"min=1,max=100"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []federated.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag `json:"tag,omitempty"`
	Type []string  `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetFederatedNetworkParams defines parameters for GetFederatedNetwork.
type GetFederatedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// GetFederatedPlatformParams defines parameters for GetFederatedPlatform.
type GetFederatedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`
}

// GetFederatedTxIDParams defines parameters for GetFederatedTxID.
type GetFederatedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// ActionPage Specify the pagination for actions
	ActionPage *int `default:"1" form:"action_page,omitempty" json:"action_page,omitempty" query:"action_page" validate:"min=1"`
}

// GetFederatedAccountParams defines parameters for GetFederatedAccount.
type GetFederatedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit *int `default:"100" form:"limit,omitempty" json:"limit,omitempty" query:"limit" validate:"min=1,max=100"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit *int `default:"10" form:"action_limit,omitempty" json:"action_limit,omitempty" query:"action_limit" validate:"min=1,max=20"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty" query:"cursor"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty" query:"since_timestamp"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty" query:"until_timestamp"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty" query:"success"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty" query:"direction"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty" query:"network"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty" query:"tag"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty" query:"-"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty" query:"platform"`
}

// PostDecentralizedAccountsJSONRequestBody defines body for PostDecentralizedAccounts for application/json ContentType.
type PostDecentralizedAccountsJSONRequestBody PostDecentralizedAccountsJSONBody

// PostDecentralizedMetadataJSONRequestBody defines body for PostDecentralizedMetadata for application/json ContentType.
type PostDecentralizedMetadataJSONRequestBody PostDecentralizedMetadataJSONBody

// PostFederatedAccountsJSONRequestBody defines body for PostFederatedAccounts for application/json ContentType.
type PostFederatedAccountsJSONRequestBody PostFederatedAccountsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Batch Get Accounts Activities
	// (POST /decentralized/accounts)
	PostDecentralizedAccounts(ctx echo.Context) error
	// Batch Get Activities By Metadata
	// (POST /decentralized/metadata)
	PostDecentralizedMetadata(ctx echo.Context) error
	// Get Network Activities
	// (GET /decentralized/network/{network})
	GetDecentralizedNetwork(ctx echo.Context, network network.Network, params GetDecentralizedNetworkParams) error
	// Get Platform Activities
	// (GET /decentralized/platform/{platform})
	GetDecentralizedPlatform(ctx echo.Context, platform decentralized.Platform, params GetDecentralizedPlatformParams) error
	// Get Activity by ID
	// (GET /decentralized/tx/{id})
	GetDecentralizedTxID(ctx echo.Context, id string, params GetDecentralizedTxIDParams) error
	// Get Account Activities
	// (GET /decentralized/{account})
	GetDecentralizedAccount(ctx echo.Context, account string, params GetDecentralizedAccountParams) error
	// Batch Get Accounts Activities
	// (POST /federated/accounts)
	PostFederatedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /federated/network/{network})
	GetFederatedNetwork(ctx echo.Context, network network.Network, params GetFederatedNetworkParams) error
	// Get Platform Activities
	// (GET /federated/platform/{platform})
	GetFederatedPlatform(ctx echo.Context, platform federated.Platform, params GetFederatedPlatformParams) error
	// Get Activity by ID
	// (GET /federated/tx/{id})
	GetFederatedTxID(ctx echo.Context, id string, params GetFederatedTxIDParams) error
	// Get Account Activities
	// (GET /federated/{account})
	GetFederatedAccount(ctx echo.Context, account string, params GetFederatedAccountParams) error
	// Get worker config options
	// (GET /networks/config)
	GetNetworksConfig(ctx echo.Context) error
	// Get Node Operator Info
	// (GET /operators)
	GetNodeOperatorInfo(ctx echo.Context) error
	// Get Node Activity Count
	// (GET /operators/activity_count)
	GetActivityCount(ctx echo.Context) error
	// Get Node Status
	// (GET /operators/info)
	GetNodeInfo(ctx echo.Context) error
	// Get Node Worker Status
	// (GET /operators/workers_status)
	GetWorkersStatus(ctx echo.Context) error
	// Get RSS Activity by Path
	// (GET /rss/{path})
	GetRSS(ctx echo.Context, path string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostDecentralizedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedAccounts(ctx)
	return err
}

// PostDecentralizedMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedMetadata(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedMetadata(ctx)
	return err
}

// GetDecentralizedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	//err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "network", &network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedNetworkParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedNetwork(ctx, network, params)
	return err
}

// GetDecentralizedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform decentralized.Platform

	//err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "platform", &platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedPlatformParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedPlatform(ctx, platform, params)
	return err
}

// GetDecentralizedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	//err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "id", &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedTxIDParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedTxID(ctx, id, params)
	return err
}

// GetDecentralizedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	//err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "account", &account)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedAccountParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedAccount(ctx, account, params)
	return err
}

// PostFederatedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostFederatedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFederatedAccounts(ctx)
	return err
}

// GetFederatedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	//err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "network", &network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedNetworkParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedNetwork(ctx, network, params)
	return err
}

// GetFederatedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform federated.Platform

	//err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "platform", &platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedPlatformParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedPlatform(ctx, platform, params)
	return err
}

// GetFederatedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	//err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "id", &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedTxIDParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedTxID(ctx, id, params)
	return err
}

// GetFederatedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	//err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "account", &account)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedAccountParams

	binder := new(echo.DefaultBinder)
	err = binder.BindQueryParams(ctx, &params)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Error unmarshaling query parameters: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedAccount(ctx, account, params)
	return err
}

// GetNetworksConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworksConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworksConfig(ctx)
	return err
}

// GetNodeOperatorInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeOperatorInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeOperatorInfo(ctx)
	return err
}

// GetActivityCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetActivityCount(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetActivityCount(ctx)
	return err
}

// GetNodeInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeInfo(ctx)
	return err
}

// GetWorkersStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkersStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkersStatus(ctx)
	return err
}

// GetRSS converts echo context to params.
func (w *ServerInterfaceWrapper) GetRSS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	//err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	err = BindPath(ctx, "path", &path)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRSS(ctx, path)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/decentralized/accounts", wrapper.PostDecentralizedAccounts)
	router.POST(baseURL+"/decentralized/metadata", wrapper.PostDecentralizedMetadata)
	router.GET(baseURL+"/decentralized/network/:network", wrapper.GetDecentralizedNetwork)
	router.GET(baseURL+"/decentralized/platform/:platform", wrapper.GetDecentralizedPlatform)
	router.GET(baseURL+"/decentralized/tx/:id", wrapper.GetDecentralizedTxID)
	router.GET(baseURL+"/decentralized/:account", wrapper.GetDecentralizedAccount)
	router.POST(baseURL+"/federated/accounts", wrapper.PostFederatedAccounts)
	router.GET(baseURL+"/federated/network/:network", wrapper.GetFederatedNetwork)
	router.GET(baseURL+"/federated/platform/:platform", wrapper.GetFederatedPlatform)
	router.GET(baseURL+"/federated/tx/:id", wrapper.GetFederatedTxID)
	router.GET(baseURL+"/federated/:account", wrapper.GetFederatedAccount)
	router.GET(baseURL+"/networks/config", wrapper.GetNetworksConfig)
	router.GET(baseURL+"/operators", wrapper.GetNodeOperatorInfo)
	router.GET(baseURL+"/operators/activity_count", wrapper.GetActivityCount)
	router.GET(baseURL+"/operators/info", wrapper.GetNodeInfo)
	router.GET(baseURL+"/operators/workers_status", wrapper.GetWorkersStatus)
	router.GET(baseURL+"/rss/:path", wrapper.GetRSS)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/5e+BJ6WJgEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
