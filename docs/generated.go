// Package docs provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package docs

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	"github.com/rss3-network/node/schema/worker/atproto"
	"github.com/rss3-network/node/schema/worker/decentralized"
	"github.com/rss3-network/node/schema/worker/federated"
	"github.com/rss3-network/protocol-go/schema"
	activityx "github.com/rss3-network/protocol-go/schema/activity"
	"github.com/rss3-network/protocol-go/schema/network"
	tag "github.com/rss3-network/protocol-go/schema/tag"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// GetAtprotoAccountParams defines parameters for GetAtprotoAccount.
type GetAtprotoAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `query:"limit,omitempty" default:"20" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `query:"action_limit,omitempty" default:"10" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `query:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `query:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `query:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `query:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `query:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `query:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `query:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `query:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []atproto.Platform `query:"platform,omitempty" json:"platform,omitempty"`
}

// PostDecentralizedAccountsJSONBody defines parameters for PostDecentralizedAccounts.
type PostDecentralizedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   int               `json:"limit,omitempty"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []decentralized.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag     `json:"tag,omitempty"`
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetDecentralizedNetworkParams defines parameters for GetDecentralizedNetwork.
type GetDecentralizedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetDecentralizedPlatformParams defines parameters for GetDecentralizedPlatform.
type GetDecentralizedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetDecentralizedTxIDParams defines parameters for GetDecentralizedTxID.
type GetDecentralizedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetDecentralizedAccountParams defines parameters for GetDecentralizedAccount.
type GetDecentralizedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []decentralized.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostFederatedAccountsJSONBody defines parameters for PostFederatedAccounts.
type PostFederatedAccountsJSONBody struct {
	Accounts []string `json:"accounts,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve
	ActionLimit int `json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination
	Cursor    *string              `json:"cursor,omitempty"`
	Direction *activityx.Direction `json:"direction,omitempty"`

	// Limit Specify the number of activities to retrieve
	Limit   int               `json:"limit,omitempty"`
	Network []network.Network `json:"network,omitempty"`

	// Platform Retrieve activities from the specified platform(s)
	Platform []federated.Platform `json:"platform,omitempty"`

	// SinceTimestamp The timestamp of when the activity occurred.
	SinceTimestamp *uint64 `json:"since_timestamp,omitempty"`

	// Status Retrieve activities based on success status
	Status *bool `json:"success,omitempty"`

	// Tag Retrieve activities for the specified tag(s)
	Tag  []tag.Tag     `json:"tag,omitempty"`
	Type []schema.Type `json:"type,omitempty"`

	// UntilTimestamp The timestamp of when the activity occurred.
	UntilTimestamp *uint64 `json:"until_timestamp,omitempty"`
}

// GetFederatedNetworkParams defines parameters for GetFederatedNetwork.
type GetFederatedNetworkParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// GetFederatedPlatformParams defines parameters for GetFederatedPlatform.
type GetFederatedPlatformParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`
}

// GetFederatedTxIDParams defines parameters for GetFederatedTxID.
type GetFederatedTxIDParams struct {
	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// ActionPage Specify the pagination for actions
	ActionPage int `form:"action_page,omitempty" json:"action_page,omitempty"`
}

// GetFederatedAccountParams defines parameters for GetFederatedAccount.
type GetFederatedAccountParams struct {
	// Limit Specify the number of activities to retrieve.
	Limit int `form:"limit,omitempty" json:"limit,omitempty"`

	// ActionLimit Specify the number of actions within the activity to retrieve.
	ActionLimit int `form:"action_limit,omitempty" json:"action_limit,omitempty"`

	// Cursor Specify the cursor used for pagination.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// SinceTimestamp Retrieve activities starting from this timestamp.
	SinceTimestamp *uint64 `form:"since_timestamp,omitempty" json:"since_timestamp,omitempty"`

	// UntilTimestamp Retrieve activities up to this timestamp.
	UntilTimestamp *uint64 `form:"until_timestamp,omitempty" json:"until_timestamp,omitempty"`

	// Status Retrieve activities based on success status.
	Status *bool `form:"success,omitempty" json:"success,omitempty"`

	// Direction Retrieve activities based on direction.
	Direction *activityx.Direction `form:"direction,omitempty" json:"direction,omitempty"`

	// Network Retrieve activities from the specified network(s).
	Network []network.Network `form:"network,omitempty" json:"network,omitempty"`

	// Tag Retrieve activities for the specified tag(s).
	Tag []tag.Tag `form:"tag,omitempty" json:"tag,omitempty"`

	// Type Retrieve activities for the specified type(s).
	Type []schema.Type `form:"type,omitempty" json:"type,omitempty"`

	// Platform Retrieve activities from the specified platform(s).
	Platform []federated.Platform `form:"platform,omitempty" json:"platform,omitempty"`
}

// PostDecentralizedAccountsJSONRequestBody defines body for PostDecentralizedAccounts for application/json ContentType.
type PostDecentralizedAccountsJSONRequestBody PostDecentralizedAccountsJSONBody

// PostFederatedAccountsJSONRequestBody defines body for PostFederatedAccounts for application/json ContentType.
type PostFederatedAccountsJSONRequestBody PostFederatedAccountsJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get Node Operator Info
	// (GET /)
	GetNodeOperatorInfo(ctx echo.Context) error
	// Get Node Activity Count
	// (GET /activity_count)
	GetActivityCount(ctx echo.Context) error
	// Get Account Activities
	// (GET /atproto/{account})
	GetAtprotoAccount(ctx echo.Context, account string, params GetAtprotoAccountParams) error
	// Batch Get Accounts Activities
	// (POST /decentralized/accounts)
	PostDecentralizedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /decentralized/network/{network})
	GetDecentralizedNetwork(ctx echo.Context, network network.Network, params GetDecentralizedNetworkParams) error
	// Get Platform Activities
	// (GET /decentralized/platform/{platform})
	GetDecentralizedPlatform(ctx echo.Context, platform decentralized.Platform, params GetDecentralizedPlatformParams) error
	// Get Activity by ID
	// (GET /decentralized/tx/{id})
	GetDecentralizedTxID(ctx echo.Context, id string, params GetDecentralizedTxIDParams) error
	// Get Account Activities
	// (GET /decentralized/{account})
	GetDecentralizedAccount(ctx echo.Context, account string, params GetDecentralizedAccountParams) error
	// Batch Get Accounts Activities
	// (POST /federated/accounts)
	PostFederatedAccounts(ctx echo.Context) error
	// Get Network Activities
	// (GET /federated/network/{network})
	GetFederatedNetwork(ctx echo.Context, network network.Network, params GetFederatedNetworkParams) error
	// Get Platform Activities
	// (GET /federated/platform/{platform})
	GetFederatedPlatform(ctx echo.Context, platform federated.Platform, params GetFederatedPlatformParams) error
	// Get Activity by ID
	// (GET /federated/tx/{id})
	GetFederatedTxID(ctx echo.Context, id string, params GetFederatedTxIDParams) error
	// Get Account Activities
	// (GET /federated/{account})
	GetFederatedAccount(ctx echo.Context, account string, params GetFederatedAccountParams) error
	// Get worker config options
	// (GET /networks/config)
	GetNetworksConfig(ctx echo.Context) error
	// Get Node Status
	// (GET /operators/info)
	GetNodeInfo(ctx echo.Context) error
	// Get Node Worker Status
	// (GET /operators/workers_status)
	GetWorkersStatus(ctx echo.Context) error
	// Get RSS Activity by Path
	// (GET /rss/{path})
	GetRSS(ctx echo.Context, path string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetNodeOperatorInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeOperatorInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeOperatorInfo(ctx)
	return err
}

// GetActivityCount converts echo context to params.
func (w *ServerInterfaceWrapper) GetActivityCount(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetActivityCount(ctx)
	return err
}

// GetAtprotoAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetAtprotoAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	var params GetAtprotoAccountParams

	if err := ctx.Bind(&params); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAtprotoAccount(ctx, account, params)
	return err
}

// PostDecentralizedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostDecentralizedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostDecentralizedAccounts(ctx)
	return err
}

// GetDecentralizedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedNetwork(ctx, network, params)
	return err
}

// GetDecentralizedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform decentralized.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedPlatform(ctx, platform, params)
	return err
}

// GetDecentralizedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedTxID(ctx, id, params)
	return err
}

// GetDecentralizedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetDecentralizedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDecentralizedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDecentralizedAccount(ctx, account, params)
	return err
}

// PostFederatedAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) PostFederatedAccounts(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFederatedAccounts(ctx)
	return err
}

// GetFederatedNetwork converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedNetwork(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "network" -------------
	var network network.Network

	err = runtime.BindStyledParameterWithOptions("simple", "network", ctx.Param("network"), &network, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedNetworkParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedNetwork(ctx, network, params)
	return err
}

// GetFederatedPlatform converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedPlatform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "platform" -------------
	var platform federated.Platform

	err = runtime.BindStyledParameterWithOptions("simple", "platform", ctx.Param("platform"), &platform, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedPlatformParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedPlatform(ctx, platform, params)
	return err
}

// GetFederatedTxID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedTxID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedTxIDParams
	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "action_page" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_page", ctx.QueryParams(), &params.ActionPage)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_page: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedTxID(ctx, id, params)
	return err
}

// GetFederatedAccount converts echo context to params.
func (w *ServerInterfaceWrapper) GetFederatedAccount(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account" -------------
	var account string

	err = runtime.BindStyledParameterWithOptions("simple", "account", ctx.Param("account"), &account, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFederatedAccountParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "action_limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "action_limit", ctx.QueryParams(), &params.ActionLimit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter action_limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// ------------- Optional query parameter "since_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_timestamp", ctx.QueryParams(), &params.SinceTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_timestamp: %s", err))
	}

	// ------------- Optional query parameter "until_timestamp" -------------

	err = runtime.BindQueryParameter("form", true, false, "until_timestamp", ctx.QueryParams(), &params.UntilTimestamp)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter until_timestamp: %s", err))
	}

	// ------------- Optional query parameter "success" -------------

	err = runtime.BindQueryParameter("form", true, false, "success", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter success: %s", err))
	}

	// ------------- Optional query parameter "direction" -------------

	err = runtime.BindQueryParameter("form", true, false, "direction", ctx.QueryParams(), &params.Direction)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter direction: %s", err))
	}

	// ------------- Optional query parameter "network" -------------

	err = runtime.BindQueryParameter("form", true, false, "network", ctx.QueryParams(), &params.Network)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter network: %s", err))
	}

	// ------------- Optional query parameter "tag" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag", ctx.QueryParams(), &params.Tag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "platform" -------------

	err = runtime.BindQueryParameter("form", true, false, "platform", ctx.QueryParams(), &params.Platform)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter platform: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFederatedAccount(ctx, account, params)
	return err
}

// GetNetworksConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetNetworksConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNetworksConfig(ctx)
	return err
}

// GetNodeInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetNodeInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNodeInfo(ctx)
	return err
}

// GetWorkersStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkersStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkersStatus(ctx)
	return err
}

// GetRSS converts echo context to params.
func (w *ServerInterfaceWrapper) GetRSS(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", ctx.Param("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter path: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRSS(ctx, path)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/", wrapper.GetNodeOperatorInfo)
	router.GET(baseURL+"/activity_count", wrapper.GetActivityCount)
	router.GET(baseURL+"/atproto/:account", wrapper.GetAtprotoAccount)
	router.POST(baseURL+"/decentralized/accounts", wrapper.PostDecentralizedAccounts)
	router.GET(baseURL+"/decentralized/network/:network", wrapper.GetDecentralizedNetwork)
	router.GET(baseURL+"/decentralized/platform/:platform", wrapper.GetDecentralizedPlatform)
	router.GET(baseURL+"/decentralized/tx/:id", wrapper.GetDecentralizedTxID)
	router.GET(baseURL+"/decentralized/:account", wrapper.GetDecentralizedAccount)
	router.POST(baseURL+"/federated/accounts", wrapper.PostFederatedAccounts)
	router.GET(baseURL+"/federated/network/:network", wrapper.GetFederatedNetwork)
	router.GET(baseURL+"/federated/platform/:platform", wrapper.GetFederatedPlatform)
	router.GET(baseURL+"/federated/tx/:id", wrapper.GetFederatedTxID)
	router.GET(baseURL+"/federated/:account", wrapper.GetFederatedAccount)
	router.GET(baseURL+"/networks/config", wrapper.GetNetworksConfig)
	router.GET(baseURL+"/operators/info", wrapper.GetNodeInfo)
	router.GET(baseURL+"/operators/workers_status", wrapper.GetWorkersStatus)
	router.GET(baseURL+"/rss/:path", wrapper.GetRSS)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9i2/bOPLwv0LofsDe4XMc+W0HONymSfe2+Npuvji7i7tePoOWaJsXSdSSVBxvkf/9",
	"B770pBzbsd2mzRbY2JbIGQ6Hw+FwHp8dj4QxiVDEmXP22YkhhSHiiJa+TWLIFxPoeSSJ+ATymBJOxCs+",
	"Yh7FMcckcs6ca8QpRvcIQI/je8wxYmBGSQj4AgEWIw/PMPKB7qfpNBz0AMM4QBKcj33x5x4GCXLOxNez",
	"OPDOlvEq6g285YLTP9okiAbLXrgK2NR5fGw4WIAVyDkNJ4KhaKd7dxoORX8kmCLfOeM0QQ2HeQsUQgHj",
	"fyiaOWfOX06z4Z+qp+nfybka5bnuTkCrI4iPPBRxCgP8J/L3SBbnzHEf/KEP+9NZuz/qd+Fs5A8Q8kfI",
	"7aBep9vq+Z0BhKO+2+05B6XGZX6Im9BkhnxEId8rPSSbvE/uIPvzZ0KJj7w7nGeZH0vPfoxJ0GTEwzBw",
	"HhsOQ9Bb+DBcFNqkv/7YcsW/ZhwcmrV+MrRZT0hJnNUEryOhjzjEAQMzQivkU+3Bu8sSRw27Luq2/d6g",
	"g6aoNZu1B3CEuqNWtzfoTLvI7bWGM8/vD3veYDbqdFp+pzWCUzTsdWeDoYs6dk7D/lq68FUs3mKc4mhu",
	"HXCE+JLQu535Rbcvrh/EF4iiJLTjbEA+d0KvhKTwSPBR92cbXhxAPiM03JO0MN017SMzj/e78K9Mr2sH",
	"+Pylf6zBpQtx7cAoYzutwOvxGGjEM4aEU69mUOrbjivojwTRlZQZJJoEOMS8ivJYYraSWEZJOEUUkBlQ",
	"bRhYYr7AkXyYig5OANXjLC6rlmsGIQHnRWQOg623XNn4vWy7bnwxnKP1w4vhHEdQPJDzoseYH0JrLf4S",
	"wm7oX4mmVuy9hDJC1yOu3gEJQ77EPBtIs4biutdtkb1QzayI+pgiTyG3yQKeQoEtiUDarg7XrONdJexl",
	"2oMV8605Xw+hltHbdYy+G4ev4e09bX9/ZX+ro362222HtN7VmB3vVOw/91hgOlozgpzgz4aAOQrZllp9",
	"Ju8bRq5CSqEA9XAyJyfitxN2h+MTIkcBg5OY4IgjquTyekrsd4c/KD1qtvdDUGV/asFBKWLRCfZIDYYj",
	"D004DhHjMIw3IwXjkHIczQ1NMANpD3WEKAPadtHfpC3t40g8D63Vi2wbhG4lBsQTVou67ntblMe63aOe",
	"IN3dWAJzbKPgcL4hM1aUOw7na9hQdLw1xeG8RsQq7tsRz1WM1iEqut4a01WMalBNIo6Dbfk7icUGvBlf",
	"lwE8h68flbqNGH9DfKzMC9kPq8kbyL3FPxG3GT/YeYq/aOaRiKNIqh4wjgPsSZ3t9L9MKVEZjjElMaKm",
	"mbYosOfJ7dSMsKOgajjlg8PW2nrDybTbbdTPhlNQNndUBRvOVpinOOd0ru0UoUa20exhMxOs/uU27YZj",
	"2ZS2XEoNJ7chbCmrtRDeXESacW4lrBqORTRtvxFqCpPpf5HHlQgpz76UH2BK/JUUx1MhRMzpQmziJXEd",
	"JgHHcYBAKgvKRoCCmMqkUtmK+IUlUtWo+SqNvgtptD+F+VUSfe2SSIoiFpOIGW1Jf8muy0yX1/rRVrKo",
	"OIKbBQIGAmCcJh5PKFIWPRBgxotWHKEyFoWZD3lNt/bWu5gS9IhXFa5/bDgh4hsrph8QhzmjXEb4T2oY",
	"txtMuSKYmvYlZOa8NUuCppOfuskb6Gv22Gp6NhnHW0rlENYihxkIYSCEhTgYUiAwgDhiAEf3MMA+yA4W",
	"JcxLiu93w222cb8snrOOYKd5s5P9WVTclmo3hMPgCs71OXh/VMqpUd8Nb5fH/LL4uoL9kXnaSr2vhp/f",
	"Cf0ugoHaFo622ZxHAGvIgCF6jyhA4l1APC+hFPlgucABAjElAm+hDfFsSKUxaE37gkQzPN9pdrfQ5xWU",
	"S8EAz6H7R+Kjd9GMHA5dDWAPmPKfSBL5x9VEsqMPRYwk1EMSy4hwMBPYlJC8Ho93EsjpTaJZ058+O+Y2",
	"WnwWRzHnzFkul0049ZoR4k2YOGr9GiEAE74gVL2vraBvwxCC31dRhJzH2/Lw/pO4bsfz8b38gNTXRVt9",
	"excBtiCUn6mfT83v6musvnzE3gIFWB4SvIRxEiIKLnDkr8A19haQ+oxEgMEVA2yBhDZH7hFdLlAg9Lkl",
	"5gvgEcZZA+DICxJf9ENRxBsgJJTP4RwBGPlASC0G/AQp8y8CAYnmwEeB6FhMbIDktccCUbAgCUNNjXRs",
	"wXm8QGABGZCzgHzRJVS3DaI5S2JEYRQlyimARECOYoFjMKdivhmYJopRKRJCD/lWYIZcvy8g/4GBCD3w",
	"f6yj5O/n4IKEIRL89QFHmHFEwThB4G0QILoSpMMR4DC4Ux4YygmAhDGMVgBOScIlfwb3RkJJEhnakMhQ",
	"KxTvm6liAIrNHXo4mltHcZoxRyS2+mQ68SFX993t7ok7OHHbN273rNU56wybruv+22k4HHN5Ja74QC3p",
	"OCZM0XoqNAGJJY4ABBFaggUJEZiuQESWTfAuYhxBX/DLD0zjBqYwuqNJzL1V0YjhXI/HPydTef4MxNY2",
	"SWggFoCz4DxmZ6enxQVzGqElO81wP40yBj4RaJxMExwINjxR9DrxYMLkQ80Fpy2363YHw5YrlQM4d84c",
	"Ku+gOLGtT71BzhDy1QrM7EYOSbjTqF3Z2HfOjjGMhoMjHz04Z27OsiTGtJCEJcsIURt+qflkBgOGSrTI",
	"TBatQWs0HPXaw1EtiYRKMUmFXatMtMfGk+rPQbTNTJS/LD3zd0LvEN15T99dwbwwjwTsPaiH6cRLTK7H",
	"486J1n1Sa+rJP8mEohmbLBD02SSEOJqQGEUwxpMPyMc2w7XvU232K3nKNZwQhyi9Ra360ZWG09gFp2y7",
	"JhH6ZSY363XE3RqE0QgmFyQIhKyZBug8jim5l97Nx4CWGAP3EYC9SeiRIH3A8rLiCJBuKPTR0UBFbIbo",
	"AaG9ffAWMJqj9/iPBPtKmh4cFoHREcCMObxTouPgkJYwPiCYfwq9PIKRh64oiQk7qKjIgP1G+CH5XEjb",
	"e0TZoYVECufAIiKFc2gBkQd0aPFwPR4fsPexjOqRR6uDTo2Cc4kCdFCOVmDe47vDAzkwLysgV4QdAQgl",
	"MxygY8B5WB0cyjW6xwwdAcwSUv/gYMYLSA85GCnA1NnyCEpwDtobiv35kUZ24O0tB+nAQiEHKdt5bvdx",
	"8Lohdyja7jDoIw+HMMg/xBFHc7kbOirackZoCLl60u9m9p7ci8oSa+k/hpQhf4JDOEeThAbWlxiHkS8W",
	"4tmeaY6iJJyMTe8C0iqcEjsSCcWFwYrvjeprOlR2A6rs5Sx9o8/pMAgOcY4WCKbq9/55Xnaf4/cDQRib",
	"qOZDdJ47Rx4Iwq/RXUSWhyJOquYeqP/r8Vgy6WF6z45ReRmZLcfdRILFanSeOjqKN5yzTw6UT5C0u9+T",
	"O+QcBr6yI1XBexRBLqBPZTD5DEfSUcNpOJ4gR+A0nCT21SvaUUh8OQiS8ihWRXGarJyGw1AgkCEzsZGJ",
	"r1zgaLBP8d4fYpd5t1SDC44EDvKygaFgVgWX87vUoa33mK8empe5MMzMMxOHMaHSkJyLhZUNnIaKTj5z",
	"5pgvkmnTI+EpZaxzoi8WTmMzkDnR3H8KUxv7zqOuWJgsHOsLTpkSSslSzIGaQMnAoeHkWLqgsiSOA/Fh",
	"ifnCp3C5x+nJm6fWsLVBhSLBImKBN5xAjk09Z2i/XFMyZ1UxYxzeCcBJZD55AcThHlEo2oSqGMxk6DKc",
	"QxwxMW1wyjjE0R4xKBpX6lZ0gBk3C3t/sD9mHt0GXKJ3voYD6RRzKlNTQLpEUHIrvIdiuU0hU3JQku6E",
	"hZDyE28B5ZKfYu4R+cmjhLGpEka5TBczSD3IuJRN84gwzOQIIwSdhhNCxokv136EoHiFxByHmImWMQlW",
	"c/ksvShk8F48uWeBlBYBXMl+p0GC2N3qKaFjknJ8TGOPbQJne+kS5TJt7Kgj520IaxdthJZyjSwpjPNb",
	"kPy+P2bJGRusOzPBUU6w7RFu7ihiwP2acunb64sTGQQvPrT6Pf1p0G6Z31o982Nr1B84Defj26uTVre1",
	"RxRvlGN+dQ15OU214SCj1TeceaZEqStdpQ829EW2TgrUcHhOU78tJI7J+lrH3xzOmzdwvje+5nCexq9u",
	"EC+xIzmrxpOj6oIVc0oVuo9iwmSChf1u12tvUQ936FRmCnFeKEdbbRJrtG+Nv+yrkPF/6fR+uzcSJ+lA",
	"D07hw1KycHapTqhHGN/7dOqxPR5ufqSl8RiTc6gBSAPmSx6Auvp78esjr2R/M6sjtVm/OAar+micHXML",
	"qjvAi7kSA948ynhngpb8++w7X4rOXu4k7F4rX4bwmUHiseHAUAZmH4zUQhuHHFGlSh1okVunLwf5MFNo",
	"PIK+yCwW7TePDSdGFBO/igyKirdX4qB6wnGIbNc6MqvQpq+XCK/aNiRAG8G5uZY7JhMooAea/yWMq/RW",
	"Pt4Hk1zkeHvlc2hkcTKrUGpK/JX1DhJF/mQaEO/O+lTdxlZ+DnBkf18dlIvbSuWlsse3ZOZaJErchv09",
	"c1jJa+6oAsZqnZWCXO8T1WtviqB2La/S9SCLfq0v4zFFQdHr8MWpgkVnxpeL/vEOSsdbh9Y7CrkOX855",
	"qepb+uJ47Ho8tshfE32Z21KKb9R4Atk22fLWU4iasfkSpZF5m2p1OkrvMGEuNe63h5voOrfSvU57wcf3",
	"mxiLdCT+JkZy4M3qiCO50rLcJl1q3QRr1WYd9jfRLnyV5wsY+YHdPzE08XOHMbyo8DyLrIvVVeukRqeP",
	"k6mJXqx7hSrf5YMduFgShpDaCc7hfMtjBYd0jvjh9OECy2potYxUSDa2gXfrMbcR48d/1KOP7fr/sbHW",
	"cXiKif0I+xBjxTWbbdFr1qZxGrYv6jtk5816V+T1Sy517D3OJD+svtAUP+TsznHGbMeJTREQH1aTesY6",
	"BLV1MMk3sXFep1L/5Y9FhcW88KHYYm+OurDr/VfEJi6T+Uw2TKb6PL++bN89GrgDG9b3KImqQVNfikkK",
	"TkavLPJ1ssiLNKqWQ+he8gBenN2uEqtU8V6ULp5TwVkNJ1Tus1yaj7XjpwrfgEnZ/+0ZDobF8LIcRkHq",
	"giFvnO6ULylbSp/igMB9ws+FEOUwiM21ScO5J/uKmykFXBUc69fSfX/QTThWPqwAIX+PEHS0Xd49XJs+",
	"G46v7IbpQGMiIwnMOUPr/8qNFisXZKXQNhwmtcGGE+C7fc5GPvqwZkmo/diyNvY9N8aR3OK9bQNiy+Yv",
	"84DNYBJw56zlNvZZ1LBQENBtOCF8wKHAsu1KoqgvrYqBZIuE9tXagIXx7BtMsWixNYWazPwmiCSpohqk",
	"1GmqWC+OxG7s/P+/mirMn9yTETz58/zk37f/52//46ybuiwtur2AYEwRE9sIgBHAkY/vsZ/AQE+ZmTEY",
	"FVHa2u2iroxzMbXmNhUe0hxfpXoLO5adK2Y2LJPpPM109+v1ewb0yyZPJsyqLBpz5FNB3FXr5HxbAtzA",
	"+WZuKfW036ZcQgpWhtraFM+6TPw15wz2dErBGpnxnNoAJLKR34NBsFUOPvP+3mqUzBDaPMO0NGQ9b9nZ",
	"ylgL8icR/iNBAPso4niGEU2LmOWp/xR761yXNgDyUSrvzC6gZ1hMftOe3yE7rmXacKrbmOg3qbnqXJq7",
	"UmYPwuTZNU82U/jtEiGX5dgEVkmyPK+My7PETDH1qI0r5CubaQx2/thElD0vt0PV86yRq+GqOF6vSkmu",
	"hi47qGv6FYnQcLJPWYHFbIpun5avVzk+rQYKvtksIFQrHM2rrFDnDpFzEfGRCZlbyryop6b87OMOWlPC",
	"F0L6qNtHa00sxNhEX79sljJVJnGXpcHX710XuY2gVlOSSaFhEADxJoBMrjJuUm2v15WSSFXTWkC2sC8F",
	"8cTIR/O6BIf8pk3W6gQ35lV7p+qlrL8IhsjaG4XLmnoVcAnMNtm0eiTXE7WQsbaUhr1YnPfTZ7WSJlpj",
	"brUGXb24kD9hXDrftN1uqz90h/lMyrl461zi6t/G73WMLkel1iN57ucJk3ML/ZVjbpU/lcNQFUs7Zzrq",
	"Wn2Vt3gp2BOP6ARbBfTbrc6w2xtURtAbjQbdzrCTH0EW7J0bwEVCddBnfgiq+ai9Zgj5gNma0Xi67/x4",
	"NBIn6lllPP3RYDjsV4bT6g56nWEvP5oshj43mg9Y1gAoD0c1768Zjd7H8tiHpq88+hrqiX74eCsUq7TO",
	"sWGuDPFCMu5cKH4O59yvRazdLfHN+sljbH7WDHSrQqLP1mOqoqZzSGZyf3McRSd5BHWKgcfHSrGZ9fWz",
	"hXAovAJUl/mywtso61libZumvqZstUAkfXxQJCjbqaP1MjK3RVXzgz/hmIjZJNNN0udTQgIkM/TW+irU",
	"OZZkCtU2bgoF/SiHUqoEqbZFo9E6VecirRtZb2ZStSVBIvc3QkEM5ziCxvO8zi5irdi7gYHGaphxH5RB",
	"ZnZ+8tPt5677uAXkr8MuU1fA+EtYZ2rr6X4HNpr1haT3bamx118rKmiW8jjugz/0z/tvfmr3R/0u/Gl0",
	"OUBv/RFyO297nW6rd9kZwPNR3+32yqVzjNeN4z4MRv3um/75EL7twUGr647Q4G1rAHvTdr8/Grmd8/Zg",
	"NBqce04+RWRrmFYevwrg6pJIBSfL3pjlRzF5Fp2r9+f/SiXPmdNyrf9V2SsrbiJ1PObBqInJKX84dR+G",
	"XRd1235v0EFT1JrN2gM4Qt1Rq9sbdKZd5PZaw5nn94c9bzAbdTotv9MawSka9rqzwdBFnayoSV4305U7",
	"3Ac0u+jNBgOvd37Zu3wz7E299nDwduj6Q6/zZjj0OrP2oN9vX2RMy/NpPPPGrNJ5w3Efum67PR30UMl0",
	"ZcqkKDOUCU11Oq1efzQa9Xqdtjvqu9lkiLlIjVCO+/Dm/E3Xb83ag+n5+WDQb8OuP2y33wzdi3538NOg",
	"1Ru1291Re2ZKruyBiPaSKrmDgCmqshW/prYbcSqtmaZC3ZVhfzgatAfp7G3B2OWaLK5lQhtf2nhq26++",
	"QxNqnWR+niH1uJbTbUibc2FJDapbKEdVM8W+tICccbWIz7vIx56sYbZcSClQJFS58E3DoiY/Y4s/knW1",
	"VkH4Smysz1RC1hs1WzjyFk7DOT//7a34A+/RnHBvIdS38yx/3xuVru8NivzL81+chnMhs1Fe5NLzGbvK",
	"249jp+H8lMvQ9zOeLwI8X4jd8N3/+x3fic7/L15imZjNaTjvkbTavsc+kX9UHr/3+OPb82vxgZA7dq08",
	"CT7IE4J4O7V8fESQjk26s48kkX39EqNoLLv5JUv+dwUpnFMYL/Rn7ZtyRYJVCOmdTHJ6PR6LffAa4mgq",
	"xzg+/+2D+MMhnau0eL9GWLdUxrB/I2r1rinahQsH+v1bh4smhR1sxAWm+V2bMHLOFTp9Y55BcgkeTT5H",
	"FPk+JDJhhZwvT2UtzfGJsZGpOV/keAP/sVS8cYeXmGneCNR7geINk+NR/qXSr4jcMap4I0x5I7VkhSQk",
	"d1Bngkxz4kWaSQzzkxhFTPabzxSZY5Y4Y5Y4zyw05RIxPVkuSZYxS5IyizJ1/rkDs+jZ+GpY5W3ky0fK",
	"wmIXjUi/A3TGAlkP05MNgC9tMsxscgqt6mlbnBbaEx8zOA2Qv9vNREP2Im+iEGW79qGDjvZ7MZIWDK4U",
	"9lWFfE1hvCphPOKjGqrLluK5fb8JEWOpi469sX5lywuJXI3mXQw/2f3qjwxBb+HDcPFjyxX/mnGwzvZT",
	"KA79Ndh9KpTYweaT9vEco0/ayddn8DnIZTx5zgwd5bJ7k9Xz1Xj4lBfWd3hAtTHKN+Hls9upNb/y0ru3",
	"7f2DbFTdi2z7rn2ErELt1Uton15C1V15Z57J9vVKcftz38dK/wZGbajfiPO3CrlEC6mhPVWhThOGKDtN",
	"lSvHpF5wxiREgKMHcZ4xgdt1Wlg5hUGr1en13Fav2+633F6r1XWzy/Af3yd3kP35M6HER94d/jEmQTO7",
	"xc+SB1gRz17WmJd6ewr/NcDtw+iO+h23M+gN3dFokBvGX2LPaTh/IdPEJ0tV8Dpvq+60++3RsDcsJSjY",
	"eByn6jYdsdMKEl2nCqszGPZaG2kS680+H4z4fuIcml7+799gkbkd7HACTYdZNVRIw8PGw9rz0fqZg0Jr",
	"jy8zJLQApUKIk4tQMNYeW3Ih+VXJrx8KmbJcYG+hvOMECAZiiO2ecVmCVUuH8lnqZ4fs3nDpZVeN04t4",
	"CGKKPMzEGLPedP/NDauyGaLaQmy2iLFRJfjrQmra+ZAa2e9eg11y1fcr5DI7SN5BA/mp0YBZrAY1Pd1k",
	"Hh9GZY3QAwcMycmkiCUBZ1vaAwR6N2LnvYJzi8NNhj5WVww4mkvIZX0kFs2rY+Frur6p6wbAe4gDOA3Q",
	"tkz0Qc3qNVKB1dXTmRcnEyl48mfiWUAgzyApbNTZh91NWAw9NMHRZD61J6KsczAKUUjoKmv5NLxtct2Y",
	"IWt1bZ2JT/uDlYx60xVQVKrOWsXtbasDaQGjzDa31p3tEAC0q1olMbFcxRNFjY1hlkyp9RlhtYfjlt2r",
	"7c10Xp3vjTngUqu7eT/j1Km77G9sI0bVmFsSwUKNMw0ZCOEKRIQDlsRiNwY/39xctRtSJvEFlgJZCEvx",
	"V/epXpFmjrzr3gwGDBUuJjPXlSgJAouFuIiY6BbopwLcFAGxHSvPdAEHMa7wEXiZETyBRwjjT2pub1MF",
	"pYiUNjlXV92v1+/NrlgLTDtalDQg47BjdFPt2tuMkOKEvL+vU+W4T5+txg/FYj8wgP0GCBPGBYWUNaQh",
	"NxTNMuCHT1pxuj35pPq+/WE7xMu+yA0HxzM2mUOOlnC11p757uqnMTAvitmaIe4tVLiBODoK1AOOBZ7p",
	"W4IHcSiLBKljl9o+cID5Ku1TroJ1o1Byozy9ObNMdYr1Q7BcIIpyVyRASBx5HS+dZrannA5ugCHimtc9",
	"EnkJpSjS+aEnhqNrMEt31KwhuL66KC0EBM4VQEPMJrhU6tcZaK1fGYmK1NaIi7OOVqkmNLf7Zvut2+zZ",
	"NtRueZ90m73Hx8w3uzy4jzBExfuo7QhsWPLxtuoh/yoODyQO/0USCsxRFuCIcRh5KBVCKqoJC2LcYwgg",
	"UOd+IUEb+syDHmLCEAMr0VNAPBhk3RBl/pL01ny/IglgKEAeb4J/kQR4MAIJExSg99hDDAT4DoFoTskd",
	"+KsRs/KrOD3+bUc57ZMQ4qip+oFxnAnragREXlob4n93hMuM040vvWWVglGOLvjzpChK/p3Eaqttk6sN",
	"x1hMLGFyOS7gC8jlqAxWmZeA4nGwxEEg92wUARI1wY0QImxBksCXjBllZ7iUWBL2FnuKligUBXA1SWgw",
	"kaVRK8i/15qDfE/dhwq1gQQBWUpnBoo8hO+RuTBnQJug1yBi0wUOuCkpnlNbkj61vO5Fh9yLrsfjn5Np",
	"Jgl/vX6/1YwZhpDCPS1Qu71o3wseX1x2KgKkkvMpgdW2Siy3KrDavePLYRMKWJbCsBKZXYzFLp1n5DNw",
	"h2SSH/Wm2oLVjK/nbDu3HUP+WCIgt3AbKJqitrBZ1IT+fQFbzQ6RkhmUSoG3p4a/PUiLi3ppy9rWdv2R",
	"+MgSnO6Re0RTD7SSOVDvKLrUjXYunRjP0/R7vqy4/s1c+iRRoQ/pJjrJvDR1de+JccIsmwsLjY2SojvP",
	"LH+Ft9TCNu/ICk2iP6KiZHozf+YPWx3ot104cqfQHQ3avt9xXeiN3EHLa4/602GvJcOMPUJ9CSCAjItd",
	"j/Ipglxd/Q2GvX5/IF8Th/XsmP7JKTp0nm4em/MPdZE8CXCI+d97/0lct91PHXP+ThKuflLPOz2nUYYF",
	"lbMBqz5xH972h1PoX75t9y6HneEIou501B/12+cXvXb/stXqzDpv4MXo8h+q+7argGnZ+3cTdaR+5XD+",
	"92LIUAVed9RyO9OR27+c9dvnbwYDt9MdXl60OtNha9DvjwadN/2+12ql8ATDpORcQkl8sbfGxFs4Z53u",
	"wEymoFH6htN2h5ZoN+WkgBifaIqcObKWuM6EmGvvKm8RA6Vvh9Lp9jaD0nK7dWBuGw4LIFsgf2KqUUro",
	"ThLL1O1nrV570O82nHtEmd5+PBLKCzNn0OoOPOQ5JmDrvtVsN11LMHt+ST9h7y8+zq2jbcoOFNb45g1t",
	"crOw+PeAnA2G9bpgT73b4GXyx+qBq58CdB+mV8B6i4+KbsP5shSpaNpkM7nWr+cYrf6OTr2RRwHgCDDk",
	"kchndpejHLdugs5v+vX1O6fersw9xzO0FbPxrYV3VdACS9f2Md49FU/DolJulGOq2Oqx4Sh78BRybzFh",
	"+E+0Kz7GruwhHHO2tw7T6p67d7FZAZO6PtaaznfpcI8kqho39hu7kPcu2s4Dri4IcWe/z9s8WhUf4cOl",
	"epZZyXPOyDY8tncU3KEaURoh8Lng42ScB5vpGzs5OcUGhzkxvk5hLihhs2PB85wc67mwdGo58GSnhyPb",
	"VN9s40K8Y8J/OK+BrX1wD5XUXAaclthL9da8UU62e2GsLfgpR4Tr8fiZMUefnOVy2YRTrxkh3oTJ2sTN",
	"EtzXEWmUG/kOMUbX4/Fzoouux+NvN65I6OxbBhUVJ+NwXvEmF/za7Vkz6VcSSZQtme8whqjIF6/RQ0He",
	"Gr517FCRms+UWV9NvFAmbo4ULFQSVi86TCgvEL+OOKH8znqESmjX4/Hew4iUJVTnBXsbhhD8vooiZIHz",
	"n8R1O56P7+UHpL4u2urbuwiwBaH8TP18an5XX2P15SP2FijA9ziaAy9hnISIggsc+Stwjb0FpD4jEWBw",
	"xQBbyPAEco/ocoGC0CQI9gjjrAFw5AWJL/oRp/IGCAnlczhH6rpe3tv56mJaSj0SzYEvDsoMiAkJkPRC",
	"XyAKFiRhqKmRji04j1VWYQDjOMCKovo2TjRnSYwojKJExWmQCMhRLHAM5pQkkc/ANOEyfQ5FgnuQbwVm",
	"yPX7AvIfmPTK/8c6Sv5+DmTFauoh8AFHmHFEwThB4G0QILoSpBOLFQZ3auWqZI8kjGG0AnBKEg4oYiS4",
	"N974kkSGNiQy1ArF+2aqGIAUgRn0cDS3juI0Y47IyVf8dtpuu3viDk7c9o3bPWt1zjrDpuu6/3ZSl3VH",
	"8YFKNBTHhClaT8WeJbEU+jSI0BIsSIjAdAUismyCdxHjCPqCX35gGjcwhdEdTWLurZwndKf1sVP6qvWJ",
	"ECPK2P5jpqjafra9i7vO7LeWLNTqoZDq0vqaRb1UTyfliymrBgkZB+k7plv7rlC5zKpBEEU88+fI9Ziq",
	"obZW8nWz2NXQYtzc5DRRvhRai5V8x4rUZrZyWSrJgkT55saGhH4HqHcstN4k0iMrP2obpXiW77h0la5u",
	"sazZRMQj5UAl+rAzgLmOWE/r9NIiR+1Kr/nriuIV2Tr2UO880WHlcs06F+qljXBcNx3jumRs1zoALR+X",
	"NoVCIortUbXSyZmrmdi00NA7+li9lYN6o6t/Pw3SHEyYjJmTmx+c/5X9bVvOL2d7e567wU1ec7bor+ax",
	"mJblApUqZhFPWvJtTFqU6okqKJ4HvIrR7v4W2rT23NH/lt2IVcc+xxzoKzMZPlq/ms3db10v6vkaMZOe",
	"jOztOZzvKKOyMF8YrXa9bdCdbH3XYNrdVhDKouPsHka7Xt/gnbNdVQJidunE5mm3ST/lMMntU2WWMSk6",
	"y220srIWBc+2/d5/5XLQF054RTZ4fp7QbS0cBfOGLlOwjdNZtjFwuLljnNw8tqZ2uhzz1RvWxJm+u7QJ",
	"jU1Xs4J2RclchsRXD7J6D+eJJS/dE3yQ9loRBIVSH/V2Oc9EzldA5nSlUvmK2t6QL8eBnuqvWNfCriSJ",
	"Nzbp7em1Mk65sXaCs8IS1UPXOzEydcoyVTd+jRYIBnzxZEUmjfbYqEZ7OYttfg4TpEBeQjFfjUUPijOm",
	"CFJEzxMu1WfZtdTX5M8ZhRecx5LLHayFTUlDG4874KM43JxfvWuoeMY/EnHYT0NrYkrusa+UmwB7KFJV",
	"bLUq+OHdjaNd2tOAI5kPU8VwEzo/1Y3YqXg3Cyd3DFgn55LjtJpu09WqfQRj7Jw5nabb7KjqDgs59lPx",
	"P+15UaNwyvOaXo46srzp5Dzl3vnOmfNPxAUOv+jjgRTHgq91CgTRfdt1dZgjR2oNcvTAT+MA4iglPNQc",
	"oGtPyKATLC/xMvJqz28fTFegUpzCLpjK3tS2IT02nK5C0SbE0qFknyZvoH+tDi+icW+7xu8EX0YweKuj",
	"FTPWdM4+3TYcloQhpCtFWzVwQ12gyWsS48iv0uP11OjRmaDbYHILi37tHJurrAvZ+5MTLG1yyo3p9L+M",
	"lKe5pPHWSmZbHpCCrbTV7rbdUbvvDm3SVZpKktivL6wjDSXS+a1wFlF7wRIyoFsXbn7ELyfSp24D/bnK",
	"g+dFKCaniZ9L4x2sXgJXpgMxTGFjS1Uw7/Sz9lJ+rOXMm3x8UEoVlp8YcfSt1KXLHYI1DHOlpmF7JABs",
	"xTgKi3GP95BikjAtqjMtV4aY4YAjKm3WJq+L7FInYsmbuaUnMzMBl9bMNaIbfZXRyI7BrFGyGDRAepna",
	"kG1CQpF9NRaLURZ19JpjWfZK7uNE7AcTTbdJVt1wmy4k/ZT/+k4t8w7wO3Wgk+rs0pThyEMTnrvB276P",
	"JOI4eGYfLL3X3L6tn7tI3751lLsc3rYt17eoW7czzkzbNjRHsYxTb+1b0aZSr1jUGSN2rR89W/x23e42",
	"jT8S/hNJIn/fkruo5H6SYahFUa6FCMhokJPkmj5amNfEnYgdnbB1ygYE0p22LBZLojzN/lGR6MyI9GJF",
	"vm9Jql8Rxm1VMFgWb/JGJlusYwzzCkb5b6vJG0H5fyJ757lJf3zeSrIV3drnejreopAEA7mlwexrozBi",
	"6woxJ9fP+sPj02o5LHh/GXM/JWHJ3l9cCLp/HaufKlEwCMhSBqfmuT93c7FKl0tuobDEWwDI1BLIcXaV",
	"sdfqKAXyfEx9QJ6nqTxnt3rVUF6mhvLltIxSkY7br1tCvhiNQwuDXaWqmZ7Tz+bTweSqAfD1Ctace8vz",
	"JGsd078K2ldBeyhBm+7mr5J1P5LVSINdRSt/OP2M/Q3EqUk0W3VESW2o6qpwvfS6eXh3uQfrlbZ8Y//L",
	"CB3dQQzn6CCsvPoejRKai6aCkbbi4S9haf52zRI1hoO9mZxftY1Xw/PrkfC7V1zWGqFtMj/NGvNFzNAp",
	"9G/OBF0uYbU383Ol4/2ZnsuV+75ts3M62spKOKC5OWP4r9HUnJLk1cz8qo+8PDNzrmDV7dcrCb8N83K9",
	"9DyoWTmTn1+lSbma0mlv5uR8NbZXYfoqTL9yU/KrBH3SjFwvQo9gPk6Bv5qOn2LdV7PxJjz7JczF36b5",
	"wHLI35uZ+FWLeDURvx7nXk3DT+kimmPYqZdGha/XRIr1U1X0oBKMuQY1YW8alg5Af95UF4pmfJXWy8rE",
	"WElnjwIyyUPYqYmg3F/k4ZqIw82ZW3XzMuguY6/SQNq11FZTxCZZGPpegwJVVDFLcXnOHGTR/C9oFhTS",
	"ayeDMnb6Wegy2xyLqgak6/EYiF6s83A9Hj9b06I6IP85c5ilPP0udyoxR/kTyBXkixxTiFlSZZgYovdm",
	"mkoF72QVRx/do4DEIYo4UO8WwsPPTk9ltccFYfxs6A5VlRENppa5lJ+KYjAyk8gWg2p1MLpMZdjYtJui",
	"54u1w8uKi8dmXWenJGu3PxWOBJt1qcPG7B2epzFlj/8bAAD//wVE3f2zLAEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
